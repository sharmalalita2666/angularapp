{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FileSystemEngineHostBase = exports.SchematicNameCollisionException = exports.SchematicMissingDescriptionException = exports.SchematicMissingFieldsException = exports.CollectionMissingFieldsException = exports.CollectionMissingSchematicsMapException = exports.FactoryCannotBeResolvedException = exports.SchematicMissingFactoryException = exports.InvalidCollectionJsonException = exports.CollectionCannotBeResolvedException = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst node_1 = require(\"@angular-devkit/core/node\");\n\nconst fs_1 = require(\"fs\");\n\nconst path_1 = require(\"path\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst src_1 = require(\"../src\");\n\nconst file_system_utility_1 = require(\"./file-system-utility\");\n\nclass CollectionCannotBeResolvedException extends core_1.BaseException {\n  constructor(name) {\n    super(`Collection ${JSON.stringify(name)} cannot be resolved.`);\n  }\n\n}\n\nexports.CollectionCannotBeResolvedException = CollectionCannotBeResolvedException;\n\nclass InvalidCollectionJsonException extends core_1.BaseException {\n  constructor(_name, path, jsonException) {\n    let msg = `Collection JSON at path ${JSON.stringify(path)} is invalid.`;\n\n    if (jsonException) {\n      msg = `${msg} ${jsonException.message}`;\n    }\n\n    super(msg);\n  }\n\n}\n\nexports.InvalidCollectionJsonException = InvalidCollectionJsonException;\n\nclass SchematicMissingFactoryException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematic ${JSON.stringify(name)} is missing a factory.`);\n  }\n\n}\n\nexports.SchematicMissingFactoryException = SchematicMissingFactoryException;\n\nclass FactoryCannotBeResolvedException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematic ${JSON.stringify(name)} cannot resolve the factory.`);\n  }\n\n}\n\nexports.FactoryCannotBeResolvedException = FactoryCannotBeResolvedException;\n\nclass CollectionMissingSchematicsMapException extends core_1.BaseException {\n  constructor(name) {\n    super(`Collection \"${name}\" does not have a schematics map.`);\n  }\n\n}\n\nexports.CollectionMissingSchematicsMapException = CollectionMissingSchematicsMapException;\n\nclass CollectionMissingFieldsException extends core_1.BaseException {\n  constructor(name) {\n    super(`Collection \"${name}\" is missing fields.`);\n  }\n\n}\n\nexports.CollectionMissingFieldsException = CollectionMissingFieldsException;\n\nclass SchematicMissingFieldsException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematic \"${name}\" is missing fields.`);\n  }\n\n}\n\nexports.SchematicMissingFieldsException = SchematicMissingFieldsException;\n\nclass SchematicMissingDescriptionException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematics \"${name}\" does not have a description.`);\n  }\n\n}\n\nexports.SchematicMissingDescriptionException = SchematicMissingDescriptionException;\n\nclass SchematicNameCollisionException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematics/alias ${JSON.stringify(name)} collides with another alias or schematic` + ' name.');\n  }\n\n}\n\nexports.SchematicNameCollisionException = SchematicNameCollisionException;\n/**\n * A EngineHost base class that uses the file system to resolve collections. This is the base of\n * all other EngineHost provided by the tooling part of the Schematics library.\n */\n\nclass FileSystemEngineHostBase {\n  constructor() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this._transforms = [];\n    this._contextTransforms = [];\n    this._taskFactories = new Map();\n  }\n\n  listSchematicNames(collection) {\n    const schematics = [];\n\n    for (const key of Object.keys(collection.schematics)) {\n      const schematic = collection.schematics[key];\n\n      if (schematic.hidden || schematic.private) {\n        continue;\n      } // If extends is present without a factory it is an alias, do not return it\n      //   unless it is from another collection.\n\n\n      if (!schematic.extends || schematic.factory) {\n        schematics.push(key);\n      } else if (schematic.extends && schematic.extends.indexOf(':') !== -1) {\n        schematics.push(key);\n      }\n    }\n\n    return schematics;\n  }\n\n  registerOptionsTransform(t) {\n    this._transforms.push(t);\n  }\n\n  registerContextTransform(t) {\n    this._contextTransforms.push(t);\n  }\n  /**\n   *\n   * @param name\n   * @return {{path: string}}\n   */\n\n\n  createCollectionDescription(name, requester) {\n    const path = this._resolveCollectionPath(name, requester === null || requester === void 0 ? void 0 : requester.path);\n\n    const jsonValue = (0, file_system_utility_1.readJsonFile)(path);\n\n    if (!jsonValue || typeof jsonValue != 'object' || Array.isArray(jsonValue)) {\n      throw new InvalidCollectionJsonException(name, path);\n    } // normalize extends property to an array\n\n\n    if (typeof jsonValue['extends'] === 'string') {\n      jsonValue['extends'] = [jsonValue['extends']];\n    }\n\n    const description = this._transformCollectionDescription(name, { ...jsonValue,\n      path\n    });\n\n    if (!description || !description.name) {\n      throw new InvalidCollectionJsonException(name, path);\n    } // Validate aliases.\n\n\n    const allNames = Object.keys(description.schematics);\n\n    for (const schematicName of Object.keys(description.schematics)) {\n      const aliases = description.schematics[schematicName].aliases || [];\n\n      for (const alias of aliases) {\n        if (allNames.indexOf(alias) != -1) {\n          throw new SchematicNameCollisionException(alias);\n        }\n      }\n\n      allNames.push(...aliases);\n    }\n\n    return description;\n  }\n\n  createSchematicDescription(name, collection) {\n    // Resolve aliases first.\n    for (const schematicName of Object.keys(collection.schematics)) {\n      const schematicDescription = collection.schematics[schematicName];\n\n      if (schematicDescription.aliases && schematicDescription.aliases.indexOf(name) != -1) {\n        name = schematicName;\n        break;\n      }\n    }\n\n    if (!(name in collection.schematics)) {\n      return null;\n    }\n\n    const collectionPath = (0, path_1.dirname)(collection.path);\n    const partialDesc = collection.schematics[name];\n\n    if (!partialDesc) {\n      return null;\n    }\n\n    if (partialDesc.extends) {\n      const index = partialDesc.extends.indexOf(':');\n      const collectionName = index !== -1 ? partialDesc.extends.substr(0, index) : null;\n      const schematicName = index === -1 ? partialDesc.extends : partialDesc.extends.substr(index + 1);\n\n      if (collectionName !== null) {\n        const extendCollection = this.createCollectionDescription(collectionName);\n        return this.createSchematicDescription(schematicName, extendCollection);\n      } else {\n        return this.createSchematicDescription(schematicName, collection);\n      }\n    } // Use any on this ref as we don't have the OptionT here, but we don't need it (we only need\n    // the path).\n\n\n    if (!partialDesc.factory) {\n      throw new SchematicMissingFactoryException(name);\n    }\n\n    const resolvedRef = this._resolveReferenceString(partialDesc.factory, collectionPath);\n\n    if (!resolvedRef) {\n      throw new FactoryCannotBeResolvedException(name);\n    }\n\n    let schema = partialDesc.schema;\n    let schemaJson = undefined;\n\n    if (schema) {\n      if (!(0, path_1.isAbsolute)(schema)) {\n        schema = (0, path_1.join)(collectionPath, schema);\n      }\n\n      schemaJson = (0, file_system_utility_1.readJsonFile)(schema);\n    } // The schematic path is used to resolve URLs.\n    // We should be able to just do `dirname(resolvedRef.path)` but for compatibility with\n    // Bazel under Windows this directory needs to be resolved from the collection instead.\n    // This is needed because on Bazel under Windows the data files (such as the collection or\n    // url files) are not in the same place as the compiled JS.\n\n\n    const maybePath = (0, path_1.join)(collectionPath, partialDesc.factory);\n    const path = (0, fs_1.existsSync)(maybePath) && (0, fs_1.statSync)(maybePath).isDirectory() ? maybePath : (0, path_1.dirname)(maybePath);\n    return this._transformSchematicDescription(name, collection, { ...partialDesc,\n      schema,\n      schemaJson,\n      name,\n      path,\n      factoryFn: resolvedRef.ref,\n      collection\n    });\n  }\n\n  createSourceFromUrl(url) {\n    switch (url.protocol) {\n      case null:\n      case 'file:':\n        return context => {\n          // Check if context has necessary FileSystemSchematicContext path property\n          const fileDescription = context.schematic.description;\n\n          if (fileDescription.path === undefined) {\n            throw new Error('Unsupported schematic context. Expected a FileSystemSchematicContext.');\n          } // Resolve all file:///a/b/c/d from the schematic's own path, and not the current\n          // path.\n\n\n          const root = (0, core_1.normalize)((0, path_1.resolve)(fileDescription.path, url.path || ''));\n          return new src_1.HostCreateTree(new core_1.virtualFs.ScopedHost(new node_1.NodeJsSyncHost(), root));\n        };\n    }\n\n    return null;\n  }\n\n  transformOptions(schematic, options, context) {\n    var _this = this;\n\n    const transform = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        let transformedOptions = options;\n\n        for (const transformer of _this._transforms) {\n          const transformerResult = transformer(schematic, transformedOptions, context);\n          transformedOptions = yield (0, rxjs_1.isObservable)(transformerResult) ? transformerResult.toPromise() : transformerResult;\n        }\n\n        return transformedOptions;\n      });\n\n      return function transform() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    return (0, rxjs_1.from)(transform());\n  }\n\n  transformContext(context) {\n    return this._contextTransforms.reduce((acc, curr) => curr(acc), context);\n  }\n\n  getSchematicRuleFactory(schematic, _collection) {\n    return schematic.factoryFn;\n  }\n\n  registerTaskExecutor(factory, options) {\n    this._taskFactories.set(factory.name, () => (0, rxjs_1.from)(factory.create(options)));\n  }\n\n  createTaskExecutor(name) {\n    const factory = this._taskFactories.get(name);\n\n    if (factory) {\n      return factory();\n    }\n\n    return (0, rxjs_1.throwError)(new src_1.UnregisteredTaskException(name));\n  }\n\n  hasTaskExecutor(name) {\n    return this._taskFactories.has(name);\n  }\n\n}\n\nexports.FileSystemEngineHostBase = FileSystemEngineHostBase;","map":{"version":3,"sources":["/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@angular-devkit/schematics/tools/file-system-engine-host-base.js"],"names":["Object","defineProperty","exports","value","FileSystemEngineHostBase","SchematicNameCollisionException","SchematicMissingDescriptionException","SchematicMissingFieldsException","CollectionMissingFieldsException","CollectionMissingSchematicsMapException","FactoryCannotBeResolvedException","SchematicMissingFactoryException","InvalidCollectionJsonException","CollectionCannotBeResolvedException","core_1","require","node_1","fs_1","path_1","rxjs_1","src_1","file_system_utility_1","BaseException","constructor","name","JSON","stringify","_name","path","jsonException","msg","message","_transforms","_contextTransforms","_taskFactories","Map","listSchematicNames","collection","schematics","key","keys","schematic","hidden","private","extends","factory","push","indexOf","registerOptionsTransform","t","registerContextTransform","createCollectionDescription","requester","_resolveCollectionPath","jsonValue","readJsonFile","Array","isArray","description","_transformCollectionDescription","allNames","schematicName","aliases","alias","createSchematicDescription","schematicDescription","collectionPath","dirname","partialDesc","index","collectionName","substr","extendCollection","resolvedRef","_resolveReferenceString","schema","schemaJson","undefined","isAbsolute","join","maybePath","existsSync","statSync","isDirectory","_transformSchematicDescription","factoryFn","ref","createSourceFromUrl","url","protocol","context","fileDescription","Error","root","normalize","resolve","HostCreateTree","virtualFs","ScopedHost","NodeJsSyncHost","transformOptions","options","transform","transformedOptions","transformer","transformerResult","isObservable","toPromise","from","transformContext","reduce","acc","curr","getSchematicRuleFactory","_collection","registerTaskExecutor","set","create","createTaskExecutor","get","throwError","UnregisteredTaskException","hasTaskExecutor","has"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,wBAAR,GAAmCF,OAAO,CAACG,+BAAR,GAA0CH,OAAO,CAACI,oCAAR,GAA+CJ,OAAO,CAACK,+BAAR,GAA0CL,OAAO,CAACM,gCAAR,GAA2CN,OAAO,CAACO,uCAAR,GAAkDP,OAAO,CAACQ,gCAAR,GAA2CR,OAAO,CAACS,gCAAR,GAA2CT,OAAO,CAACU,8BAAR,GAAyCV,OAAO,CAACW,mCAAR,GAA8C,KAAK,CAArb;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,sBAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,2BAAD,CAAtB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,IAAD,CAApB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,MAAD,CAAtB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,MAAD,CAAtB;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,QAAD,CAArB;;AACA,MAAMM,qBAAqB,GAAGN,OAAO,CAAC,uBAAD,CAArC;;AACA,MAAMF,mCAAN,SAAkDC,MAAM,CAACQ,aAAzD,CAAuE;AACnEC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAO,cAAaC,IAAI,CAACC,SAAL,CAAeF,IAAf,CAAqB,sBAAzC;AACH;;AAHkE;;AAKvEtB,OAAO,CAACW,mCAAR,GAA8CA,mCAA9C;;AACA,MAAMD,8BAAN,SAA6CE,MAAM,CAACQ,aAApD,CAAkE;AAC9DC,EAAAA,WAAW,CAACI,KAAD,EAAQC,IAAR,EAAcC,aAAd,EAA6B;AACpC,QAAIC,GAAG,GAAI,2BAA0BL,IAAI,CAACC,SAAL,CAAeE,IAAf,CAAqB,cAA1D;;AACA,QAAIC,aAAJ,EAAmB;AACfC,MAAAA,GAAG,GAAI,GAAEA,GAAI,IAAGD,aAAa,CAACE,OAAQ,EAAtC;AACH;;AACD,UAAMD,GAAN;AACH;;AAP6D;;AASlE5B,OAAO,CAACU,8BAAR,GAAyCA,8BAAzC;;AACA,MAAMD,gCAAN,SAA+CG,MAAM,CAACQ,aAAtD,CAAoE;AAChEC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAO,aAAYC,IAAI,CAACC,SAAL,CAAeF,IAAf,CAAqB,wBAAxC;AACH;;AAH+D;;AAKpEtB,OAAO,CAACS,gCAAR,GAA2CA,gCAA3C;;AACA,MAAMD,gCAAN,SAA+CI,MAAM,CAACQ,aAAtD,CAAoE;AAChEC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAO,aAAYC,IAAI,CAACC,SAAL,CAAeF,IAAf,CAAqB,8BAAxC;AACH;;AAH+D;;AAKpEtB,OAAO,CAACQ,gCAAR,GAA2CA,gCAA3C;;AACA,MAAMD,uCAAN,SAAsDK,MAAM,CAACQ,aAA7D,CAA2E;AACvEC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAO,eAAcA,IAAK,mCAA1B;AACH;;AAHsE;;AAK3EtB,OAAO,CAACO,uCAAR,GAAkDA,uCAAlD;;AACA,MAAMD,gCAAN,SAA+CM,MAAM,CAACQ,aAAtD,CAAoE;AAChEC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAO,eAAcA,IAAK,sBAA1B;AACH;;AAH+D;;AAKpEtB,OAAO,CAACM,gCAAR,GAA2CA,gCAA3C;;AACA,MAAMD,+BAAN,SAA8CO,MAAM,CAACQ,aAArD,CAAmE;AAC/DC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAO,cAAaA,IAAK,sBAAzB;AACH;;AAH8D;;AAKnEtB,OAAO,CAACK,+BAAR,GAA0CA,+BAA1C;;AACA,MAAMD,oCAAN,SAAmDQ,MAAM,CAACQ,aAA1D,CAAwE;AACpEC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAO,eAAcA,IAAK,gCAA1B;AACH;;AAHmE;;AAKxEtB,OAAO,CAACI,oCAAR,GAA+CA,oCAA/C;;AACA,MAAMD,+BAAN,SAA8CS,MAAM,CAACQ,aAArD,CAAmE;AAC/DC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAO,oBAAmBC,IAAI,CAACC,SAAL,CAAeF,IAAf,CAAqB,2CAAzC,GACF,QADJ;AAEH;;AAJ8D;;AAMnEtB,OAAO,CAACG,+BAAR,GAA0CA,+BAA1C;AACA;AACA;AACA;AACA;;AACA,MAAMD,wBAAN,CAA+B;AAC3BmB,EAAAA,WAAW,GAAG;AACV;AACA,SAAKS,WAAL,GAAmB,EAAnB;AACA,SAAKC,kBAAL,GAA0B,EAA1B;AACA,SAAKC,cAAL,GAAsB,IAAIC,GAAJ,EAAtB;AACH;;AACDC,EAAAA,kBAAkB,CAACC,UAAD,EAAa;AAC3B,UAAMC,UAAU,GAAG,EAAnB;;AACA,SAAK,MAAMC,GAAX,IAAkBvC,MAAM,CAACwC,IAAP,CAAYH,UAAU,CAACC,UAAvB,CAAlB,EAAsD;AAClD,YAAMG,SAAS,GAAGJ,UAAU,CAACC,UAAX,CAAsBC,GAAtB,CAAlB;;AACA,UAAIE,SAAS,CAACC,MAAV,IAAoBD,SAAS,CAACE,OAAlC,EAA2C;AACvC;AACH,OAJiD,CAKlD;AACA;;;AACA,UAAI,CAACF,SAAS,CAACG,OAAX,IAAsBH,SAAS,CAACI,OAApC,EAA6C;AACzCP,QAAAA,UAAU,CAACQ,IAAX,CAAgBP,GAAhB;AACH,OAFD,MAGK,IAAIE,SAAS,CAACG,OAAV,IAAqBH,SAAS,CAACG,OAAV,CAAkBG,OAAlB,CAA0B,GAA1B,MAAmC,CAAC,CAA7D,EAAgE;AACjET,QAAAA,UAAU,CAACQ,IAAX,CAAgBP,GAAhB;AACH;AACJ;;AACD,WAAOD,UAAP;AACH;;AACDU,EAAAA,wBAAwB,CAACC,CAAD,EAAI;AACxB,SAAKjB,WAAL,CAAiBc,IAAjB,CAAsBG,CAAtB;AACH;;AACDC,EAAAA,wBAAwB,CAACD,CAAD,EAAI;AACxB,SAAKhB,kBAAL,CAAwBa,IAAxB,CAA6BG,CAA7B;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIE,EAAAA,2BAA2B,CAAC3B,IAAD,EAAO4B,SAAP,EAAkB;AACzC,UAAMxB,IAAI,GAAG,KAAKyB,sBAAL,CAA4B7B,IAA5B,EAAkC4B,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACxB,IAAlG,CAAb;;AACA,UAAM0B,SAAS,GAAG,CAAC,GAAGjC,qBAAqB,CAACkC,YAA1B,EAAwC3B,IAAxC,CAAlB;;AACA,QAAI,CAAC0B,SAAD,IAAc,OAAOA,SAAP,IAAoB,QAAlC,IAA8CE,KAAK,CAACC,OAAN,CAAcH,SAAd,CAAlD,EAA4E;AACxE,YAAM,IAAI1C,8BAAJ,CAAmCY,IAAnC,EAAyCI,IAAzC,CAAN;AACH,KALwC,CAMzC;;;AACA,QAAI,OAAO0B,SAAS,CAAC,SAAD,CAAhB,KAAgC,QAApC,EAA8C;AAC1CA,MAAAA,SAAS,CAAC,SAAD,CAAT,GAAuB,CAACA,SAAS,CAAC,SAAD,CAAV,CAAvB;AACH;;AACD,UAAMI,WAAW,GAAG,KAAKC,+BAAL,CAAqCnC,IAArC,EAA2C,EAC3D,GAAG8B,SADwD;AAE3D1B,MAAAA;AAF2D,KAA3C,CAApB;;AAIA,QAAI,CAAC8B,WAAD,IAAgB,CAACA,WAAW,CAAClC,IAAjC,EAAuC;AACnC,YAAM,IAAIZ,8BAAJ,CAAmCY,IAAnC,EAAyCI,IAAzC,CAAN;AACH,KAhBwC,CAiBzC;;;AACA,UAAMgC,QAAQ,GAAG5D,MAAM,CAACwC,IAAP,CAAYkB,WAAW,CAACpB,UAAxB,CAAjB;;AACA,SAAK,MAAMuB,aAAX,IAA4B7D,MAAM,CAACwC,IAAP,CAAYkB,WAAW,CAACpB,UAAxB,CAA5B,EAAiE;AAC7D,YAAMwB,OAAO,GAAGJ,WAAW,CAACpB,UAAZ,CAAuBuB,aAAvB,EAAsCC,OAAtC,IAAiD,EAAjE;;AACA,WAAK,MAAMC,KAAX,IAAoBD,OAApB,EAA6B;AACzB,YAAIF,QAAQ,CAACb,OAAT,CAAiBgB,KAAjB,KAA2B,CAAC,CAAhC,EAAmC;AAC/B,gBAAM,IAAI1D,+BAAJ,CAAoC0D,KAApC,CAAN;AACH;AACJ;;AACDH,MAAAA,QAAQ,CAACd,IAAT,CAAc,GAAGgB,OAAjB;AACH;;AACD,WAAOJ,WAAP;AACH;;AACDM,EAAAA,0BAA0B,CAACxC,IAAD,EAAOa,UAAP,EAAmB;AACzC;AACA,SAAK,MAAMwB,aAAX,IAA4B7D,MAAM,CAACwC,IAAP,CAAYH,UAAU,CAACC,UAAvB,CAA5B,EAAgE;AAC5D,YAAM2B,oBAAoB,GAAG5B,UAAU,CAACC,UAAX,CAAsBuB,aAAtB,CAA7B;;AACA,UAAII,oBAAoB,CAACH,OAArB,IAAgCG,oBAAoB,CAACH,OAArB,CAA6Bf,OAA7B,CAAqCvB,IAArC,KAA8C,CAAC,CAAnF,EAAsF;AAClFA,QAAAA,IAAI,GAAGqC,aAAP;AACA;AACH;AACJ;;AACD,QAAI,EAAErC,IAAI,IAAIa,UAAU,CAACC,UAArB,CAAJ,EAAsC;AAClC,aAAO,IAAP;AACH;;AACD,UAAM4B,cAAc,GAAG,CAAC,GAAGhD,MAAM,CAACiD,OAAX,EAAoB9B,UAAU,CAACT,IAA/B,CAAvB;AACA,UAAMwC,WAAW,GAAG/B,UAAU,CAACC,UAAX,CAAsBd,IAAtB,CAApB;;AACA,QAAI,CAAC4C,WAAL,EAAkB;AACd,aAAO,IAAP;AACH;;AACD,QAAIA,WAAW,CAACxB,OAAhB,EAAyB;AACrB,YAAMyB,KAAK,GAAGD,WAAW,CAACxB,OAAZ,CAAoBG,OAApB,CAA4B,GAA5B,CAAd;AACA,YAAMuB,cAAc,GAAGD,KAAK,KAAK,CAAC,CAAX,GAAeD,WAAW,CAACxB,OAAZ,CAAoB2B,MAApB,CAA2B,CAA3B,EAA8BF,KAA9B,CAAf,GAAsD,IAA7E;AACA,YAAMR,aAAa,GAAGQ,KAAK,KAAK,CAAC,CAAX,GAAeD,WAAW,CAACxB,OAA3B,GAAqCwB,WAAW,CAACxB,OAAZ,CAAoB2B,MAApB,CAA2BF,KAAK,GAAG,CAAnC,CAA3D;;AACA,UAAIC,cAAc,KAAK,IAAvB,EAA6B;AACzB,cAAME,gBAAgB,GAAG,KAAKrB,2BAAL,CAAiCmB,cAAjC,CAAzB;AACA,eAAO,KAAKN,0BAAL,CAAgCH,aAAhC,EAA+CW,gBAA/C,CAAP;AACH,OAHD,MAIK;AACD,eAAO,KAAKR,0BAAL,CAAgCH,aAAhC,EAA+CxB,UAA/C,CAAP;AACH;AACJ,KA5BwC,CA6BzC;AACA;;;AACA,QAAI,CAAC+B,WAAW,CAACvB,OAAjB,EAA0B;AACtB,YAAM,IAAIlC,gCAAJ,CAAqCa,IAArC,CAAN;AACH;;AACD,UAAMiD,WAAW,GAAG,KAAKC,uBAAL,CAA6BN,WAAW,CAACvB,OAAzC,EAAkDqB,cAAlD,CAApB;;AACA,QAAI,CAACO,WAAL,EAAkB;AACd,YAAM,IAAI/D,gCAAJ,CAAqCc,IAArC,CAAN;AACH;;AACD,QAAImD,MAAM,GAAGP,WAAW,CAACO,MAAzB;AACA,QAAIC,UAAU,GAAGC,SAAjB;;AACA,QAAIF,MAAJ,EAAY;AACR,UAAI,CAAC,CAAC,GAAGzD,MAAM,CAAC4D,UAAX,EAAuBH,MAAvB,CAAL,EAAqC;AACjCA,QAAAA,MAAM,GAAG,CAAC,GAAGzD,MAAM,CAAC6D,IAAX,EAAiBb,cAAjB,EAAiCS,MAAjC,CAAT;AACH;;AACDC,MAAAA,UAAU,GAAG,CAAC,GAAGvD,qBAAqB,CAACkC,YAA1B,EAAwCoB,MAAxC,CAAb;AACH,KA7CwC,CA8CzC;AACA;AACA;AACA;AACA;;;AACA,UAAMK,SAAS,GAAG,CAAC,GAAG9D,MAAM,CAAC6D,IAAX,EAAiBb,cAAjB,EAAiCE,WAAW,CAACvB,OAA7C,CAAlB;AACA,UAAMjB,IAAI,GAAG,CAAC,GAAGX,IAAI,CAACgE,UAAT,EAAqBD,SAArB,KAAmC,CAAC,GAAG/D,IAAI,CAACiE,QAAT,EAAmBF,SAAnB,EAA8BG,WAA9B,EAAnC,GAAiFH,SAAjF,GAA6F,CAAC,GAAG9D,MAAM,CAACiD,OAAX,EAAoBa,SAApB,CAA1G;AACA,WAAO,KAAKI,8BAAL,CAAoC5D,IAApC,EAA0Ca,UAA1C,EAAsD,EACzD,GAAG+B,WADsD;AAEzDO,MAAAA,MAFyD;AAGzDC,MAAAA,UAHyD;AAIzDpD,MAAAA,IAJyD;AAKzDI,MAAAA,IALyD;AAMzDyD,MAAAA,SAAS,EAAEZ,WAAW,CAACa,GANkC;AAOzDjD,MAAAA;AAPyD,KAAtD,CAAP;AASH;;AACDkD,EAAAA,mBAAmB,CAACC,GAAD,EAAM;AACrB,YAAQA,GAAG,CAACC,QAAZ;AACI,WAAK,IAAL;AACA,WAAK,OAAL;AACI,eAAQC,OAAD,IAAa;AAChB;AACA,gBAAMC,eAAe,GAAGD,OAAO,CAACjD,SAAR,CAAkBiB,WAA1C;;AACA,cAAIiC,eAAe,CAAC/D,IAAhB,KAAyBiD,SAA7B,EAAwC;AACpC,kBAAM,IAAIe,KAAJ,CAAU,uEAAV,CAAN;AACH,WALe,CAMhB;AACA;;;AACA,gBAAMC,IAAI,GAAG,CAAC,GAAG/E,MAAM,CAACgF,SAAX,EAAsB,CAAC,GAAG5E,MAAM,CAAC6E,OAAX,EAAoBJ,eAAe,CAAC/D,IAApC,EAA0C4D,GAAG,CAAC5D,IAAJ,IAAY,EAAtD,CAAtB,CAAb;AACA,iBAAO,IAAIR,KAAK,CAAC4E,cAAV,CAAyB,IAAIlF,MAAM,CAACmF,SAAP,CAAiBC,UAArB,CAAgC,IAAIlF,MAAM,CAACmF,cAAX,EAAhC,EAA6DN,IAA7D,CAAzB,CAAP;AACH,SAVD;AAHR;;AAeA,WAAO,IAAP;AACH;;AACDO,EAAAA,gBAAgB,CAAC3D,SAAD,EAAY4D,OAAZ,EAAqBX,OAArB,EAA8B;AAAA;;AAC1C,UAAMY,SAAS;AAAA,mCAAG,aAAY;AAC1B,YAAIC,kBAAkB,GAAGF,OAAzB;;AACA,aAAK,MAAMG,WAAX,IAA0B,KAAI,CAACxE,WAA/B,EAA4C;AACxC,gBAAMyE,iBAAiB,GAAGD,WAAW,CAAC/D,SAAD,EAAY8D,kBAAZ,EAAgCb,OAAhC,CAArC;AACAa,UAAAA,kBAAkB,SAAU,CAAC,GAAGpF,MAAM,CAACuF,YAAX,EAAyBD,iBAAzB,IACtBA,iBAAiB,CAACE,SAAlB,EADsB,GAEtBF,iBAFN;AAGH;;AACD,eAAOF,kBAAP;AACH,OATc;;AAAA,sBAATD,SAAS;AAAA;AAAA;AAAA,OAAf;;AAUA,WAAO,CAAC,GAAGnF,MAAM,CAACyF,IAAX,EAAiBN,SAAS,EAA1B,CAAP;AACH;;AACDO,EAAAA,gBAAgB,CAACnB,OAAD,EAAU;AACtB,WAAO,KAAKzD,kBAAL,CAAwB6E,MAAxB,CAA+B,CAACC,GAAD,EAAMC,IAAN,KAAeA,IAAI,CAACD,GAAD,CAAlD,EAAyDrB,OAAzD,CAAP;AACH;;AACDuB,EAAAA,uBAAuB,CAACxE,SAAD,EAAYyE,WAAZ,EAAyB;AAC5C,WAAOzE,SAAS,CAAC4C,SAAjB;AACH;;AACD8B,EAAAA,oBAAoB,CAACtE,OAAD,EAAUwD,OAAV,EAAmB;AACnC,SAAKnE,cAAL,CAAoBkF,GAApB,CAAwBvE,OAAO,CAACrB,IAAhC,EAAsC,MAAM,CAAC,GAAGL,MAAM,CAACyF,IAAX,EAAiB/D,OAAO,CAACwE,MAAR,CAAehB,OAAf,CAAjB,CAA5C;AACH;;AACDiB,EAAAA,kBAAkB,CAAC9F,IAAD,EAAO;AACrB,UAAMqB,OAAO,GAAG,KAAKX,cAAL,CAAoBqF,GAApB,CAAwB/F,IAAxB,CAAhB;;AACA,QAAIqB,OAAJ,EAAa;AACT,aAAOA,OAAO,EAAd;AACH;;AACD,WAAO,CAAC,GAAG1B,MAAM,CAACqG,UAAX,EAAuB,IAAIpG,KAAK,CAACqG,yBAAV,CAAoCjG,IAApC,CAAvB,CAAP;AACH;;AACDkG,EAAAA,eAAe,CAAClG,IAAD,EAAO;AAClB,WAAO,KAAKU,cAAL,CAAoByF,GAApB,CAAwBnG,IAAxB,CAAP;AACH;;AAlL0B;;AAoL/BtB,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileSystemEngineHostBase = exports.SchematicNameCollisionException = exports.SchematicMissingDescriptionException = exports.SchematicMissingFieldsException = exports.CollectionMissingFieldsException = exports.CollectionMissingSchematicsMapException = exports.FactoryCannotBeResolvedException = exports.SchematicMissingFactoryException = exports.InvalidCollectionJsonException = exports.CollectionCannotBeResolvedException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst node_1 = require(\"@angular-devkit/core/node\");\nconst fs_1 = require(\"fs\");\nconst path_1 = require(\"path\");\nconst rxjs_1 = require(\"rxjs\");\nconst src_1 = require(\"../src\");\nconst file_system_utility_1 = require(\"./file-system-utility\");\nclass CollectionCannotBeResolvedException extends core_1.BaseException {\n    constructor(name) {\n        super(`Collection ${JSON.stringify(name)} cannot be resolved.`);\n    }\n}\nexports.CollectionCannotBeResolvedException = CollectionCannotBeResolvedException;\nclass InvalidCollectionJsonException extends core_1.BaseException {\n    constructor(_name, path, jsonException) {\n        let msg = `Collection JSON at path ${JSON.stringify(path)} is invalid.`;\n        if (jsonException) {\n            msg = `${msg} ${jsonException.message}`;\n        }\n        super(msg);\n    }\n}\nexports.InvalidCollectionJsonException = InvalidCollectionJsonException;\nclass SchematicMissingFactoryException extends core_1.BaseException {\n    constructor(name) {\n        super(`Schematic ${JSON.stringify(name)} is missing a factory.`);\n    }\n}\nexports.SchematicMissingFactoryException = SchematicMissingFactoryException;\nclass FactoryCannotBeResolvedException extends core_1.BaseException {\n    constructor(name) {\n        super(`Schematic ${JSON.stringify(name)} cannot resolve the factory.`);\n    }\n}\nexports.FactoryCannotBeResolvedException = FactoryCannotBeResolvedException;\nclass CollectionMissingSchematicsMapException extends core_1.BaseException {\n    constructor(name) {\n        super(`Collection \"${name}\" does not have a schematics map.`);\n    }\n}\nexports.CollectionMissingSchematicsMapException = CollectionMissingSchematicsMapException;\nclass CollectionMissingFieldsException extends core_1.BaseException {\n    constructor(name) {\n        super(`Collection \"${name}\" is missing fields.`);\n    }\n}\nexports.CollectionMissingFieldsException = CollectionMissingFieldsException;\nclass SchematicMissingFieldsException extends core_1.BaseException {\n    constructor(name) {\n        super(`Schematic \"${name}\" is missing fields.`);\n    }\n}\nexports.SchematicMissingFieldsException = SchematicMissingFieldsException;\nclass SchematicMissingDescriptionException extends core_1.BaseException {\n    constructor(name) {\n        super(`Schematics \"${name}\" does not have a description.`);\n    }\n}\nexports.SchematicMissingDescriptionException = SchematicMissingDescriptionException;\nclass SchematicNameCollisionException extends core_1.BaseException {\n    constructor(name) {\n        super(`Schematics/alias ${JSON.stringify(name)} collides with another alias or schematic` +\n            ' name.');\n    }\n}\nexports.SchematicNameCollisionException = SchematicNameCollisionException;\n/**\n * A EngineHost base class that uses the file system to resolve collections. This is the base of\n * all other EngineHost provided by the tooling part of the Schematics library.\n */\nclass FileSystemEngineHostBase {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this._transforms = [];\n        this._contextTransforms = [];\n        this._taskFactories = new Map();\n    }\n    listSchematicNames(collection) {\n        const schematics = [];\n        for (const key of Object.keys(collection.schematics)) {\n            const schematic = collection.schematics[key];\n            if (schematic.hidden || schematic.private) {\n                continue;\n            }\n            // If extends is present without a factory it is an alias, do not return it\n            //   unless it is from another collection.\n            if (!schematic.extends || schematic.factory) {\n                schematics.push(key);\n            }\n            else if (schematic.extends && schematic.extends.indexOf(':') !== -1) {\n                schematics.push(key);\n            }\n        }\n        return schematics;\n    }\n    registerOptionsTransform(t) {\n        this._transforms.push(t);\n    }\n    registerContextTransform(t) {\n        this._contextTransforms.push(t);\n    }\n    /**\n     *\n     * @param name\n     * @return {{path: string}}\n     */\n    createCollectionDescription(name, requester) {\n        const path = this._resolveCollectionPath(name, requester === null || requester === void 0 ? void 0 : requester.path);\n        const jsonValue = (0, file_system_utility_1.readJsonFile)(path);\n        if (!jsonValue || typeof jsonValue != 'object' || Array.isArray(jsonValue)) {\n            throw new InvalidCollectionJsonException(name, path);\n        }\n        // normalize extends property to an array\n        if (typeof jsonValue['extends'] === 'string') {\n            jsonValue['extends'] = [jsonValue['extends']];\n        }\n        const description = this._transformCollectionDescription(name, {\n            ...jsonValue,\n            path,\n        });\n        if (!description || !description.name) {\n            throw new InvalidCollectionJsonException(name, path);\n        }\n        // Validate aliases.\n        const allNames = Object.keys(description.schematics);\n        for (const schematicName of Object.keys(description.schematics)) {\n            const aliases = description.schematics[schematicName].aliases || [];\n            for (const alias of aliases) {\n                if (allNames.indexOf(alias) != -1) {\n                    throw new SchematicNameCollisionException(alias);\n                }\n            }\n            allNames.push(...aliases);\n        }\n        return description;\n    }\n    createSchematicDescription(name, collection) {\n        // Resolve aliases first.\n        for (const schematicName of Object.keys(collection.schematics)) {\n            const schematicDescription = collection.schematics[schematicName];\n            if (schematicDescription.aliases && schematicDescription.aliases.indexOf(name) != -1) {\n                name = schematicName;\n                break;\n            }\n        }\n        if (!(name in collection.schematics)) {\n            return null;\n        }\n        const collectionPath = (0, path_1.dirname)(collection.path);\n        const partialDesc = collection.schematics[name];\n        if (!partialDesc) {\n            return null;\n        }\n        if (partialDesc.extends) {\n            const index = partialDesc.extends.indexOf(':');\n            const collectionName = index !== -1 ? partialDesc.extends.substr(0, index) : null;\n            const schematicName = index === -1 ? partialDesc.extends : partialDesc.extends.substr(index + 1);\n            if (collectionName !== null) {\n                const extendCollection = this.createCollectionDescription(collectionName);\n                return this.createSchematicDescription(schematicName, extendCollection);\n            }\n            else {\n                return this.createSchematicDescription(schematicName, collection);\n            }\n        }\n        // Use any on this ref as we don't have the OptionT here, but we don't need it (we only need\n        // the path).\n        if (!partialDesc.factory) {\n            throw new SchematicMissingFactoryException(name);\n        }\n        const resolvedRef = this._resolveReferenceString(partialDesc.factory, collectionPath);\n        if (!resolvedRef) {\n            throw new FactoryCannotBeResolvedException(name);\n        }\n        let schema = partialDesc.schema;\n        let schemaJson = undefined;\n        if (schema) {\n            if (!(0, path_1.isAbsolute)(schema)) {\n                schema = (0, path_1.join)(collectionPath, schema);\n            }\n            schemaJson = (0, file_system_utility_1.readJsonFile)(schema);\n        }\n        // The schematic path is used to resolve URLs.\n        // We should be able to just do `dirname(resolvedRef.path)` but for compatibility with\n        // Bazel under Windows this directory needs to be resolved from the collection instead.\n        // This is needed because on Bazel under Windows the data files (such as the collection or\n        // url files) are not in the same place as the compiled JS.\n        const maybePath = (0, path_1.join)(collectionPath, partialDesc.factory);\n        const path = (0, fs_1.existsSync)(maybePath) && (0, fs_1.statSync)(maybePath).isDirectory() ? maybePath : (0, path_1.dirname)(maybePath);\n        return this._transformSchematicDescription(name, collection, {\n            ...partialDesc,\n            schema,\n            schemaJson,\n            name,\n            path,\n            factoryFn: resolvedRef.ref,\n            collection,\n        });\n    }\n    createSourceFromUrl(url) {\n        switch (url.protocol) {\n            case null:\n            case 'file:':\n                return (context) => {\n                    // Check if context has necessary FileSystemSchematicContext path property\n                    const fileDescription = context.schematic.description;\n                    if (fileDescription.path === undefined) {\n                        throw new Error('Unsupported schematic context. Expected a FileSystemSchematicContext.');\n                    }\n                    // Resolve all file:///a/b/c/d from the schematic's own path, and not the current\n                    // path.\n                    const root = (0, core_1.normalize)((0, path_1.resolve)(fileDescription.path, url.path || ''));\n                    return new src_1.HostCreateTree(new core_1.virtualFs.ScopedHost(new node_1.NodeJsSyncHost(), root));\n                };\n        }\n        return null;\n    }\n    transformOptions(schematic, options, context) {\n        const transform = async () => {\n            let transformedOptions = options;\n            for (const transformer of this._transforms) {\n                const transformerResult = transformer(schematic, transformedOptions, context);\n                transformedOptions = await ((0, rxjs_1.isObservable)(transformerResult)\n                    ? transformerResult.toPromise()\n                    : transformerResult);\n            }\n            return transformedOptions;\n        };\n        return (0, rxjs_1.from)(transform());\n    }\n    transformContext(context) {\n        return this._contextTransforms.reduce((acc, curr) => curr(acc), context);\n    }\n    getSchematicRuleFactory(schematic, _collection) {\n        return schematic.factoryFn;\n    }\n    registerTaskExecutor(factory, options) {\n        this._taskFactories.set(factory.name, () => (0, rxjs_1.from)(factory.create(options)));\n    }\n    createTaskExecutor(name) {\n        const factory = this._taskFactories.get(name);\n        if (factory) {\n            return factory();\n        }\n        return (0, rxjs_1.throwError)(new src_1.UnregisteredTaskException(name));\n    }\n    hasTaskExecutor(name) {\n        return this._taskFactories.has(name);\n    }\n}\nexports.FileSystemEngineHostBase = FileSystemEngineHostBase;\n"]},"metadata":{},"sourceType":"script"}