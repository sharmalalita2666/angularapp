{"ast":null,"code":"'use strict';\n\nconst _ = {\n  isPlainObject: require('lodash/isPlainObject'),\n  clone: require('lodash/clone'),\n  isArray: require('lodash/isArray'),\n  get: require('lodash/get'),\n  set: require('lodash/set'),\n  isFunction: require('lodash/isFunction')\n};\n\nconst {\n  defer,\n  empty,\n  from,\n  of\n} = require('rxjs');\n\nconst {\n  concatMap,\n  filter,\n  publish,\n  reduce\n} = require('rxjs/operators');\n\nconst runAsync = require('run-async');\n\nconst utils = require('../utils/utils');\n\nconst Base = require('./baseUI');\n/**\n * Base interface class other can inherits from\n */\n\n\nclass PromptUI extends Base {\n  constructor(prompts, opt) {\n    super(opt);\n    this.prompts = prompts;\n  }\n\n  run(questions, answers) {\n    // Keep global reference to the answers\n    if (_.isPlainObject(answers)) {\n      this.answers = _.clone(answers);\n    } else {\n      this.answers = {};\n    } // Make sure questions is an array.\n\n\n    if (_.isPlainObject(questions)) {\n      // It's either an object of questions or a single question\n      questions = Object.values(questions).every(v => _.isPlainObject(v) && v.name === undefined) ? Object.entries(questions).map(([name, question]) => ({\n        name,\n        ...question\n      })) : [questions];\n    } // Create an observable, unless we received one as parameter.\n    // Note: As this is a public interface, we cannot do an instanceof check as we won't\n    // be using the exact same object in memory.\n\n\n    const obs = _.isArray(questions) ? from(questions) : questions;\n    this.process = obs.pipe(concatMap(this.processQuestion.bind(this)), publish() // Creates a hot Observable. It prevents duplicating prompts.\n    );\n    this.process.connect();\n    return this.process.pipe(reduce((answers, answer) => {\n      _.set(answers, answer.name, answer.answer);\n\n      return answers;\n    }, this.answers)).toPromise(Promise).then(this.onCompletion.bind(this), this.onError.bind(this));\n  }\n  /**\n   * Once all prompt are over\n   */\n\n\n  onCompletion() {\n    this.close();\n    return this.answers;\n  }\n\n  onError(error) {\n    this.close();\n    return Promise.reject(error);\n  }\n\n  processQuestion(question) {\n    question = _.clone(question);\n    return defer(() => {\n      const obs = of(question);\n      return obs.pipe(concatMap(this.setDefaultType.bind(this)), concatMap(this.filterIfRunnable.bind(this)), concatMap(() => utils.fetchAsyncQuestionProperty(question, 'message', this.answers)), concatMap(() => utils.fetchAsyncQuestionProperty(question, 'default', this.answers)), concatMap(() => utils.fetchAsyncQuestionProperty(question, 'choices', this.answers)), concatMap(this.fetchAnswer.bind(this)));\n    });\n  }\n\n  fetchAnswer(question) {\n    const Prompt = this.prompts[question.type];\n    this.activePrompt = new Prompt(question, this.rl, this.answers);\n    return defer(() => from(this.activePrompt.run().then(answer => ({\n      name: question.name,\n      answer\n    }))));\n  }\n\n  setDefaultType(question) {\n    // Default type to input\n    if (!this.prompts[question.type]) {\n      question.type = 'input';\n    }\n\n    return defer(() => of(question));\n  }\n\n  filterIfRunnable(question) {\n    if (question.askAnswered !== true && _.get(this.answers, question.name) !== undefined) {\n      return empty();\n    }\n\n    if (question.when === false) {\n      return empty();\n    }\n\n    if (!_.isFunction(question.when)) {\n      return of(question);\n    }\n\n    const {\n      answers\n    } = this;\n    return defer(() => from(runAsync(question.when)(answers).then(shouldRun => {\n      if (shouldRun) {\n        return question;\n      }\n    })).pipe(filter(val => val != null)));\n  }\n\n}\n\nmodule.exports = PromptUI;","map":{"version":3,"sources":["/home/unthinkable-lap-0268/Documents/angularProject/node_modules/inquirer/lib/ui/prompt.js"],"names":["_","isPlainObject","require","clone","isArray","get","set","isFunction","defer","empty","from","of","concatMap","filter","publish","reduce","runAsync","utils","Base","PromptUI","constructor","prompts","opt","run","questions","answers","Object","values","every","v","name","undefined","entries","map","question","obs","process","pipe","processQuestion","bind","connect","answer","toPromise","Promise","then","onCompletion","onError","close","error","reject","setDefaultType","filterIfRunnable","fetchAsyncQuestionProperty","fetchAnswer","Prompt","type","activePrompt","rl","askAnswered","when","shouldRun","val","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst _ = {\n  isPlainObject: require('lodash/isPlainObject'),\n  clone: require('lodash/clone'),\n  isArray: require('lodash/isArray'),\n  get: require('lodash/get'),\n  set: require('lodash/set'),\n  isFunction: require('lodash/isFunction'),\n};\nconst { defer, empty, from, of } = require('rxjs');\nconst { concatMap, filter, publish, reduce } = require('rxjs/operators');\nconst runAsync = require('run-async');\nconst utils = require('../utils/utils');\nconst Base = require('./baseUI');\n\n/**\n * Base interface class other can inherits from\n */\n\nclass PromptUI extends Base {\n  constructor(prompts, opt) {\n    super(opt);\n    this.prompts = prompts;\n  }\n\n  run(questions, answers) {\n    // Keep global reference to the answers\n    if (_.isPlainObject(answers)) {\n      this.answers = _.clone(answers);\n    } else {\n      this.answers = {};\n    }\n\n    // Make sure questions is an array.\n    if (_.isPlainObject(questions)) {\n      // It's either an object of questions or a single question\n      questions = Object.values(questions).every(\n        (v) => _.isPlainObject(v) && v.name === undefined\n      )\n        ? Object.entries(questions).map(([name, question]) => ({ name, ...question }))\n        : [questions];\n    }\n\n    // Create an observable, unless we received one as parameter.\n    // Note: As this is a public interface, we cannot do an instanceof check as we won't\n    // be using the exact same object in memory.\n    const obs = _.isArray(questions) ? from(questions) : questions;\n\n    this.process = obs.pipe(\n      concatMap(this.processQuestion.bind(this)),\n      publish() // Creates a hot Observable. It prevents duplicating prompts.\n    );\n\n    this.process.connect();\n\n    return this.process\n      .pipe(\n        reduce((answers, answer) => {\n          _.set(answers, answer.name, answer.answer);\n          return answers;\n        }, this.answers)\n      )\n      .toPromise(Promise)\n      .then(this.onCompletion.bind(this), this.onError.bind(this));\n  }\n\n  /**\n   * Once all prompt are over\n   */\n\n  onCompletion() {\n    this.close();\n\n    return this.answers;\n  }\n\n  onError(error) {\n    this.close();\n    return Promise.reject(error);\n  }\n\n  processQuestion(question) {\n    question = _.clone(question);\n    return defer(() => {\n      const obs = of(question);\n\n      return obs.pipe(\n        concatMap(this.setDefaultType.bind(this)),\n        concatMap(this.filterIfRunnable.bind(this)),\n        concatMap(() =>\n          utils.fetchAsyncQuestionProperty(question, 'message', this.answers)\n        ),\n        concatMap(() =>\n          utils.fetchAsyncQuestionProperty(question, 'default', this.answers)\n        ),\n        concatMap(() =>\n          utils.fetchAsyncQuestionProperty(question, 'choices', this.answers)\n        ),\n        concatMap(this.fetchAnswer.bind(this))\n      );\n    });\n  }\n\n  fetchAnswer(question) {\n    const Prompt = this.prompts[question.type];\n    this.activePrompt = new Prompt(question, this.rl, this.answers);\n    return defer(() =>\n      from(this.activePrompt.run().then((answer) => ({ name: question.name, answer })))\n    );\n  }\n\n  setDefaultType(question) {\n    // Default type to input\n    if (!this.prompts[question.type]) {\n      question.type = 'input';\n    }\n\n    return defer(() => of(question));\n  }\n\n  filterIfRunnable(question) {\n    if (\n      question.askAnswered !== true &&\n      _.get(this.answers, question.name) !== undefined\n    ) {\n      return empty();\n    }\n\n    if (question.when === false) {\n      return empty();\n    }\n\n    if (!_.isFunction(question.when)) {\n      return of(question);\n    }\n\n    const { answers } = this;\n    return defer(() =>\n      from(\n        runAsync(question.when)(answers).then((shouldRun) => {\n          if (shouldRun) {\n            return question;\n          }\n        })\n      ).pipe(filter((val) => val != null))\n    );\n  }\n}\n\nmodule.exports = PromptUI;\n"]},"metadata":{},"sourceType":"script"}