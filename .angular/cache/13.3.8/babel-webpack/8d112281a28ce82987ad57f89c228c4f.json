{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visitJsonSchema = exports.visitJson = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst pointer_1 = require(\"./pointer\");\n\nfunction _getObjectSubSchema(schema, key) {\n  if (typeof schema !== 'object' || schema === null) {\n    return undefined;\n  } // Is it an object schema?\n\n\n  if (typeof schema.properties == 'object' || schema.type == 'object') {\n    if (typeof schema.properties == 'object' && typeof schema.properties[key] == 'object') {\n      return schema.properties[key];\n    }\n\n    if (typeof schema.additionalProperties == 'object') {\n      return schema.additionalProperties;\n    }\n\n    return undefined;\n  } // Is it an array schema?\n\n\n  if (typeof schema.items == 'object' || schema.type == 'array') {\n    return typeof schema.items == 'object' ? schema.items : undefined;\n  }\n\n  return undefined;\n}\n\nfunction _visitJsonRecursive(json, visitor, ptr, schema, refResolver, context, root) {\n  if (schema === true || schema === false) {\n    // There's no schema definition, so just visit the JSON recursively.\n    schema = undefined;\n  } // eslint-disable-next-line no-prototype-builtins\n\n\n  if (schema && schema.hasOwnProperty('$ref') && typeof schema['$ref'] == 'string') {\n    if (refResolver) {\n      const resolved = refResolver(schema['$ref'], context);\n      schema = resolved.schema;\n      context = resolved.context;\n    }\n  }\n\n  const value = visitor(json, ptr, schema, root);\n  return ((0, rxjs_1.isObservable)(value) ? value : (0, rxjs_1.of)(value)).pipe((0, operators_1.concatMap)(value => {\n    if (Array.isArray(value)) {\n      return (0, rxjs_1.concat)((0, rxjs_1.from)(value).pipe((0, operators_1.mergeMap)((item, i) => {\n        return _visitJsonRecursive(item, visitor, (0, pointer_1.joinJsonPointer)(ptr, '' + i), _getObjectSubSchema(schema, '' + i), refResolver, context, root || value).pipe((0, operators_1.tap)(x => value[i] = x));\n      }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n    } else if (typeof value == 'object' && value !== null) {\n      return (0, rxjs_1.concat)((0, rxjs_1.from)(Object.getOwnPropertyNames(value)).pipe((0, operators_1.mergeMap)(key => {\n        return _visitJsonRecursive(value[key], visitor, (0, pointer_1.joinJsonPointer)(ptr, key), _getObjectSubSchema(schema, key), refResolver, context, root || value).pipe((0, operators_1.tap)(x => {\n          const descriptor = Object.getOwnPropertyDescriptor(value, key);\n\n          if (descriptor && descriptor.writable && value[key] !== x) {\n            value[key] = x;\n          }\n        }));\n      }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n    } else {\n      return (0, rxjs_1.of)(value);\n    }\n  }));\n}\n/**\n * Visit all the properties in a JSON object, allowing to transform them. It supports calling\n * properties synchronously or asynchronously (through Observables).\n * The original object can be mutated or replaced entirely. In case where it's replaced, the new\n * value is returned. When it's mutated though the original object will be changed.\n *\n * Please note it is possible to have an infinite loop here (which will result in a stack overflow)\n * if you return 2 objects that references each others (or the same object all the time).\n *\n * @param {JsonValue} json The Json value to visit.\n * @param {JsonVisitor} visitor A function that will be called on every items.\n * @param {JsonObject} schema A JSON schema to pass through to the visitor (where possible).\n * @param refResolver a function to resolve references in the schema.\n * @returns {Observable< | undefined>} The observable of the new root, if the root changed.\n */\n\n\nfunction visitJson(json, visitor, schema, refResolver, context) {\n  return _visitJsonRecursive(json, visitor, (0, pointer_1.buildJsonPointer)([]), schema, refResolver, context);\n}\n\nexports.visitJson = visitJson;\n\nfunction visitJsonSchema(schema, visitor) {\n  if (schema === false || schema === true) {\n    // Nothing to visit.\n    return;\n  }\n\n  const keywords = {\n    additionalItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    propertyNames: true,\n    not: true\n  };\n  const arrayKeywords = {\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true\n  };\n  const propsKeywords = {\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    additionalProperties: true,\n    dependencies: true,\n    items: true\n  };\n\n  function _traverse(schema, jsonPtr, rootSchema, parentSchema, keyIndex) {\n    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n      visitor(schema, jsonPtr, parentSchema, keyIndex);\n\n      for (const key of Object.keys(schema)) {\n        const sch = schema[key];\n\n        if (key in propsKeywords) {\n          if (sch && typeof sch == 'object') {\n            for (const prop of Object.keys(sch)) {\n              _traverse(sch[prop], (0, pointer_1.joinJsonPointer)(jsonPtr, key, prop), rootSchema, schema, prop);\n            }\n          }\n        } else if (key in keywords) {\n          _traverse(sch, (0, pointer_1.joinJsonPointer)(jsonPtr, key), rootSchema, schema, key);\n        } else if (key in arrayKeywords) {\n          if (Array.isArray(sch)) {\n            for (let i = 0; i < sch.length; i++) {\n              _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n            }\n          }\n        } else if (Array.isArray(sch)) {\n          for (let i = 0; i < sch.length; i++) {\n            _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n          }\n        }\n      }\n    }\n  }\n\n  _traverse(schema, (0, pointer_1.buildJsonPointer)([]), schema);\n}\n\nexports.visitJsonSchema = visitJsonSchema;","map":{"version":3,"sources":["/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@angular-devkit/core/src/json/schema/visitor.js"],"names":["Object","defineProperty","exports","value","visitJsonSchema","visitJson","rxjs_1","require","operators_1","pointer_1","_getObjectSubSchema","schema","key","undefined","properties","type","additionalProperties","items","_visitJsonRecursive","json","visitor","ptr","refResolver","context","root","hasOwnProperty","resolved","isObservable","of","pipe","concatMap","Array","isArray","concat","from","mergeMap","item","i","joinJsonPointer","tap","x","ignoreElements","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","writable","buildJsonPointer","keywords","additionalItems","contains","propertyNames","not","arrayKeywords","allOf","anyOf","oneOf","propsKeywords","definitions","patternProperties","dependencies","_traverse","jsonPtr","rootSchema","parentSchema","keyIndex","keys","sch","prop","length"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.visitJsonSchema = exports.visitJson = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst pointer_1 = require(\"./pointer\");\nfunction _getObjectSubSchema(schema, key) {\n    if (typeof schema !== 'object' || schema === null) {\n        return undefined;\n    }\n    // Is it an object schema?\n    if (typeof schema.properties == 'object' || schema.type == 'object') {\n        if (typeof schema.properties == 'object' &&\n            typeof schema.properties[key] == 'object') {\n            return schema.properties[key];\n        }\n        if (typeof schema.additionalProperties == 'object') {\n            return schema.additionalProperties;\n        }\n        return undefined;\n    }\n    // Is it an array schema?\n    if (typeof schema.items == 'object' || schema.type == 'array') {\n        return typeof schema.items == 'object' ? schema.items : undefined;\n    }\n    return undefined;\n}\nfunction _visitJsonRecursive(json, visitor, ptr, schema, refResolver, context, root) {\n    if (schema === true || schema === false) {\n        // There's no schema definition, so just visit the JSON recursively.\n        schema = undefined;\n    }\n    // eslint-disable-next-line no-prototype-builtins\n    if (schema && schema.hasOwnProperty('$ref') && typeof schema['$ref'] == 'string') {\n        if (refResolver) {\n            const resolved = refResolver(schema['$ref'], context);\n            schema = resolved.schema;\n            context = resolved.context;\n        }\n    }\n    const value = visitor(json, ptr, schema, root);\n    return ((0, rxjs_1.isObservable)(value) ? value : (0, rxjs_1.of)(value)).pipe((0, operators_1.concatMap)((value) => {\n        if (Array.isArray(value)) {\n            return (0, rxjs_1.concat)((0, rxjs_1.from)(value).pipe((0, operators_1.mergeMap)((item, i) => {\n                return _visitJsonRecursive(item, visitor, (0, pointer_1.joinJsonPointer)(ptr, '' + i), _getObjectSubSchema(schema, '' + i), refResolver, context, root || value).pipe((0, operators_1.tap)((x) => (value[i] = x)));\n            }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n        }\n        else if (typeof value == 'object' && value !== null) {\n            return (0, rxjs_1.concat)((0, rxjs_1.from)(Object.getOwnPropertyNames(value)).pipe((0, operators_1.mergeMap)((key) => {\n                return _visitJsonRecursive(value[key], visitor, (0, pointer_1.joinJsonPointer)(ptr, key), _getObjectSubSchema(schema, key), refResolver, context, root || value).pipe((0, operators_1.tap)((x) => {\n                    const descriptor = Object.getOwnPropertyDescriptor(value, key);\n                    if (descriptor && descriptor.writable && value[key] !== x) {\n                        value[key] = x;\n                    }\n                }));\n            }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n        }\n        else {\n            return (0, rxjs_1.of)(value);\n        }\n    }));\n}\n/**\n * Visit all the properties in a JSON object, allowing to transform them. It supports calling\n * properties synchronously or asynchronously (through Observables).\n * The original object can be mutated or replaced entirely. In case where it's replaced, the new\n * value is returned. When it's mutated though the original object will be changed.\n *\n * Please note it is possible to have an infinite loop here (which will result in a stack overflow)\n * if you return 2 objects that references each others (or the same object all the time).\n *\n * @param {JsonValue} json The Json value to visit.\n * @param {JsonVisitor} visitor A function that will be called on every items.\n * @param {JsonObject} schema A JSON schema to pass through to the visitor (where possible).\n * @param refResolver a function to resolve references in the schema.\n * @returns {Observable< | undefined>} The observable of the new root, if the root changed.\n */\nfunction visitJson(json, visitor, schema, refResolver, context) {\n    return _visitJsonRecursive(json, visitor, (0, pointer_1.buildJsonPointer)([]), schema, refResolver, context);\n}\nexports.visitJson = visitJson;\nfunction visitJsonSchema(schema, visitor) {\n    if (schema === false || schema === true) {\n        // Nothing to visit.\n        return;\n    }\n    const keywords = {\n        additionalItems: true,\n        items: true,\n        contains: true,\n        additionalProperties: true,\n        propertyNames: true,\n        not: true,\n    };\n    const arrayKeywords = {\n        items: true,\n        allOf: true,\n        anyOf: true,\n        oneOf: true,\n    };\n    const propsKeywords = {\n        definitions: true,\n        properties: true,\n        patternProperties: true,\n        additionalProperties: true,\n        dependencies: true,\n        items: true,\n    };\n    function _traverse(schema, jsonPtr, rootSchema, parentSchema, keyIndex) {\n        if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n            visitor(schema, jsonPtr, parentSchema, keyIndex);\n            for (const key of Object.keys(schema)) {\n                const sch = schema[key];\n                if (key in propsKeywords) {\n                    if (sch && typeof sch == 'object') {\n                        for (const prop of Object.keys(sch)) {\n                            _traverse(sch[prop], (0, pointer_1.joinJsonPointer)(jsonPtr, key, prop), rootSchema, schema, prop);\n                        }\n                    }\n                }\n                else if (key in keywords) {\n                    _traverse(sch, (0, pointer_1.joinJsonPointer)(jsonPtr, key), rootSchema, schema, key);\n                }\n                else if (key in arrayKeywords) {\n                    if (Array.isArray(sch)) {\n                        for (let i = 0; i < sch.length; i++) {\n                            _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n                        }\n                    }\n                }\n                else if (Array.isArray(sch)) {\n                    for (let i = 0; i < sch.length; i++) {\n                        _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n                    }\n                }\n            }\n        }\n    }\n    _traverse(schema, (0, pointer_1.buildJsonPointer)([]), schema);\n}\nexports.visitJsonSchema = visitJsonSchema;\n"]},"metadata":{},"sourceType":"script"}