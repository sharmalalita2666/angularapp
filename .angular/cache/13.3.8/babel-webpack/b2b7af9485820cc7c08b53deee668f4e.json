{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseJsonSchemaToOptions = exports.parseJsonSchemaToCommandDescription = exports.parseJsonSchemaToSubCommandDescription = exports.CommandJsonPathException = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst tools_1 = require(\"@angular-devkit/schematics/tools\");\n\nconst fs_1 = require(\"fs\");\n\nconst path_1 = require(\"path\");\n\nconst interface_1 = require(\"../models/interface\");\n\nclass CommandJsonPathException extends core_1.BaseException {\n  constructor(path, name) {\n    super(`File ${path} was not found while constructing the subcommand ${name}.`);\n    this.path = path;\n    this.name = name;\n  }\n\n}\n\nexports.CommandJsonPathException = CommandJsonPathException;\n\nfunction _getEnumFromValue(value, enumeration, defaultValue) {\n  if (typeof value !== 'string') {\n    return defaultValue;\n  }\n\n  if (Object.values(enumeration).includes(value)) {\n    return value;\n  }\n\n  return defaultValue;\n}\n\nfunction parseJsonSchemaToSubCommandDescription(_x, _x2, _x3, _x4) {\n  return _parseJsonSchemaToSubCommandDescription.apply(this, arguments);\n}\n\nfunction _parseJsonSchemaToSubCommandDescription() {\n  _parseJsonSchemaToSubCommandDescription = _asyncToGenerator(function* (name, jsonPath, registry, schema) {\n    const options = yield parseJsonSchemaToOptions(registry, schema);\n    const aliases = [];\n\n    if (core_1.json.isJsonArray(schema.$aliases)) {\n      schema.$aliases.forEach(value => {\n        if (typeof value == 'string') {\n          aliases.push(value);\n        }\n      });\n    }\n\n    if (core_1.json.isJsonArray(schema.aliases)) {\n      schema.aliases.forEach(value => {\n        if (typeof value == 'string') {\n          aliases.push(value);\n        }\n      });\n    }\n\n    if (typeof schema.alias == 'string') {\n      aliases.push(schema.alias);\n    }\n\n    let longDescription = '';\n\n    if (typeof schema.$longDescription == 'string' && schema.$longDescription) {\n      const ldPath = (0, path_1.resolve)((0, path_1.dirname)(jsonPath), schema.$longDescription);\n\n      try {\n        longDescription = (0, fs_1.readFileSync)(ldPath, 'utf-8');\n      } catch (e) {\n        throw new CommandJsonPathException(ldPath, name);\n      }\n    }\n\n    let usageNotes = '';\n\n    if (typeof schema.$usageNotes == 'string' && schema.$usageNotes) {\n      const unPath = (0, path_1.resolve)((0, path_1.dirname)(jsonPath), schema.$usageNotes);\n\n      try {\n        usageNotes = (0, fs_1.readFileSync)(unPath, 'utf-8');\n      } catch (e) {\n        throw new CommandJsonPathException(unPath, name);\n      }\n    }\n\n    const description = '' + (schema.description === undefined ? '' : schema.description);\n    return {\n      name,\n      description,\n      ...(longDescription ? {\n        longDescription\n      } : {}),\n      ...(usageNotes ? {\n        usageNotes\n      } : {}),\n      options,\n      aliases\n    };\n  });\n  return _parseJsonSchemaToSubCommandDescription.apply(this, arguments);\n}\n\nexports.parseJsonSchemaToSubCommandDescription = parseJsonSchemaToSubCommandDescription;\n\nfunction parseJsonSchemaToCommandDescription(_x5, _x6, _x7, _x8) {\n  return _parseJsonSchemaToCommandDescription.apply(this, arguments);\n}\n\nfunction _parseJsonSchemaToCommandDescription() {\n  _parseJsonSchemaToCommandDescription = _asyncToGenerator(function* (name, jsonPath, registry, schema) {\n    const subcommand = yield parseJsonSchemaToSubCommandDescription(name, jsonPath, registry, schema); // Before doing any work, let's validate the implementation.\n\n    if (typeof schema.$impl != 'string') {\n      throw new Error(`Command ${name} has an invalid implementation.`);\n    }\n\n    const ref = new tools_1.ExportStringRef(schema.$impl, (0, path_1.dirname)(jsonPath));\n    const impl = ref.ref;\n\n    if (impl === undefined || typeof impl !== 'function') {\n      throw new Error(`Command ${name} has an invalid implementation.`);\n    }\n\n    const scope = _getEnumFromValue(schema.$scope, interface_1.CommandScope, interface_1.CommandScope.Default);\n\n    const hidden = !!schema.$hidden;\n    return { ...subcommand,\n      scope,\n      hidden,\n      impl\n    };\n  });\n  return _parseJsonSchemaToCommandDescription.apply(this, arguments);\n}\n\nexports.parseJsonSchemaToCommandDescription = parseJsonSchemaToCommandDescription;\n\nfunction parseJsonSchemaToOptions(_x9, _x10) {\n  return _parseJsonSchemaToOptions.apply(this, arguments);\n}\n\nfunction _parseJsonSchemaToOptions() {\n  _parseJsonSchemaToOptions = _asyncToGenerator(function* (registry, schema) {\n    const options = [];\n\n    function visitor(current, pointer, parentSchema) {\n      if (!parentSchema) {\n        // Ignore root.\n        return;\n      } else if (pointer.split(/\\/(?:properties|items|definitions)\\//g).length > 2) {\n        // Ignore subitems (objects or arrays).\n        return;\n      } else if (core_1.json.isJsonArray(current)) {\n        return;\n      }\n\n      if (pointer.indexOf('/not/') != -1) {\n        // We don't support anyOf/not.\n        throw new Error('The \"not\" keyword is not supported in JSON Schema.');\n      }\n\n      const ptr = core_1.json.schema.parseJsonPointer(pointer);\n      const name = ptr[ptr.length - 1];\n\n      if (ptr[ptr.length - 2] != 'properties') {\n        // Skip any non-property items.\n        return;\n      }\n\n      const typeSet = core_1.json.schema.getTypesOfSchema(current);\n\n      if (typeSet.size == 0) {\n        throw new Error('Cannot find type of schema.');\n      } // We only support number, string or boolean (or array of those), so remove everything else.\n\n\n      const types = [...typeSet].filter(x => {\n        switch (x) {\n          case 'boolean':\n          case 'number':\n          case 'string':\n            return true;\n\n          case 'array':\n            // Only include arrays if they're boolean, string or number.\n            if (core_1.json.isJsonObject(current.items) && typeof current.items.type == 'string' && ['boolean', 'number', 'string'].includes(current.items.type)) {\n              return true;\n            }\n\n            return false;\n\n          default:\n            return false;\n        }\n      }).map(x => _getEnumFromValue(x, interface_1.OptionType, interface_1.OptionType.String));\n\n      if (types.length == 0) {\n        // This means it's not usable on the command line. e.g. an Object.\n        return;\n      } // Only keep enum values we support (booleans, numbers and strings).\n\n\n      const enumValues = (core_1.json.isJsonArray(current.enum) && current.enum || []).filter(x => {\n        switch (typeof x) {\n          case 'boolean':\n          case 'number':\n          case 'string':\n            return true;\n\n          default:\n            return false;\n        }\n      });\n      let defaultValue = undefined;\n\n      if (current.default !== undefined) {\n        switch (types[0]) {\n          case 'string':\n            if (typeof current.default == 'string') {\n              defaultValue = current.default;\n            }\n\n            break;\n\n          case 'number':\n            if (typeof current.default == 'number') {\n              defaultValue = current.default;\n            }\n\n            break;\n\n          case 'boolean':\n            if (typeof current.default == 'boolean') {\n              defaultValue = current.default;\n            }\n\n            break;\n        }\n      }\n\n      const type = types[0];\n      const $default = current.$default;\n      const $defaultIndex = core_1.json.isJsonObject($default) && $default['$source'] == 'argv' ? $default['index'] : undefined;\n      const positional = typeof $defaultIndex == 'number' ? $defaultIndex : undefined;\n      const required = core_1.json.isJsonArray(current.required) ? current.required.indexOf(name) != -1 : false;\n      const aliases = core_1.json.isJsonArray(current.aliases) ? [...current.aliases].map(x => '' + x) : current.alias ? ['' + current.alias] : [];\n      const format = typeof current.format == 'string' ? current.format : undefined;\n      const visible = current.visible === undefined || current.visible === true;\n      const hidden = !!current.hidden || !visible;\n      const xUserAnalytics = current['x-user-analytics'];\n      const userAnalytics = typeof xUserAnalytics == 'number' ? xUserAnalytics : undefined; // Deprecated is set only if it's true or a string.\n\n      const xDeprecated = current['x-deprecated'];\n      const deprecated = xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : undefined;\n      const option = {\n        name,\n        description: '' + (current.description === undefined ? '' : current.description),\n        ...(types.length == 1 ? {\n          type\n        } : {\n          type,\n          types\n        }),\n        ...(defaultValue !== undefined ? {\n          default: defaultValue\n        } : {}),\n        ...(enumValues && enumValues.length > 0 ? {\n          enum: enumValues\n        } : {}),\n        required,\n        aliases,\n        ...(format !== undefined ? {\n          format\n        } : {}),\n        hidden,\n        ...(userAnalytics ? {\n          userAnalytics\n        } : {}),\n        ...(deprecated !== undefined ? {\n          deprecated\n        } : {}),\n        ...(positional !== undefined ? {\n          positional\n        } : {})\n      };\n      options.push(option);\n    }\n\n    const flattenedSchema = yield registry.flatten(schema).toPromise();\n    core_1.json.schema.visitJsonSchema(flattenedSchema, visitor); // Sort by positional.\n\n    return options.sort((a, b) => {\n      if (a.positional) {\n        if (b.positional) {\n          return a.positional - b.positional;\n        } else {\n          return 1;\n        }\n      } else if (b.positional) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n  });\n  return _parseJsonSchemaToOptions.apply(this, arguments);\n}\n\nexports.parseJsonSchemaToOptions = parseJsonSchemaToOptions;","map":{"version":3,"sources":["/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@angular/cli/utilities/json-schema.js"],"names":["Object","defineProperty","exports","value","parseJsonSchemaToOptions","parseJsonSchemaToCommandDescription","parseJsonSchemaToSubCommandDescription","CommandJsonPathException","core_1","require","tools_1","fs_1","path_1","interface_1","BaseException","constructor","path","name","_getEnumFromValue","enumeration","defaultValue","values","includes","jsonPath","registry","schema","options","aliases","json","isJsonArray","$aliases","forEach","push","alias","longDescription","$longDescription","ldPath","resolve","dirname","readFileSync","e","usageNotes","$usageNotes","unPath","description","undefined","subcommand","$impl","Error","ref","ExportStringRef","impl","scope","$scope","CommandScope","Default","hidden","$hidden","visitor","current","pointer","parentSchema","split","length","indexOf","ptr","parseJsonPointer","typeSet","getTypesOfSchema","size","types","filter","x","isJsonObject","items","type","map","OptionType","String","enumValues","enum","default","$default","$defaultIndex","positional","required","format","visible","xUserAnalytics","userAnalytics","xDeprecated","deprecated","option","flattenedSchema","flatten","toPromise","visitJsonSchema","sort","a","b"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,wBAAR,GAAmCF,OAAO,CAACG,mCAAR,GAA8CH,OAAO,CAACI,sCAAR,GAAiDJ,OAAO,CAACK,wBAAR,GAAmC,KAAK,CAA1K;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,sBAAD,CAAtB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,kCAAD,CAAvB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,IAAD,CAApB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,MAAD,CAAtB;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,qBAAD,CAA3B;;AACA,MAAMF,wBAAN,SAAuCC,MAAM,CAACM,aAA9C,CAA4D;AACxDC,EAAAA,WAAW,CAACC,IAAD,EAAOC,IAAP,EAAa;AACpB,UAAO,QAAOD,IAAK,oDAAmDC,IAAK,GAA3E;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACH;;AALuD;;AAO5Df,OAAO,CAACK,wBAAR,GAAmCA,wBAAnC;;AACA,SAASW,iBAAT,CAA2Bf,KAA3B,EAAkCgB,WAAlC,EAA+CC,YAA/C,EAA6D;AACzD,MAAI,OAAOjB,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAOiB,YAAP;AACH;;AACD,MAAIpB,MAAM,CAACqB,MAAP,CAAcF,WAAd,EAA2BG,QAA3B,CAAoCnB,KAApC,CAAJ,EAAgD;AAC5C,WAAOA,KAAP;AACH;;AACD,SAAOiB,YAAP;AACH;;SACcd,sC;;;;;8DAAf,WAAsDW,IAAtD,EAA4DM,QAA5D,EAAsEC,QAAtE,EAAgFC,MAAhF,EAAwF;AACpF,UAAMC,OAAO,SAAStB,wBAAwB,CAACoB,QAAD,EAAWC,MAAX,CAA9C;AACA,UAAME,OAAO,GAAG,EAAhB;;AACA,QAAInB,MAAM,CAACoB,IAAP,CAAYC,WAAZ,CAAwBJ,MAAM,CAACK,QAA/B,CAAJ,EAA8C;AAC1CL,MAAAA,MAAM,CAACK,QAAP,CAAgBC,OAAhB,CAAyB5B,KAAD,IAAW;AAC/B,YAAI,OAAOA,KAAP,IAAgB,QAApB,EAA8B;AAC1BwB,UAAAA,OAAO,CAACK,IAAR,CAAa7B,KAAb;AACH;AACJ,OAJD;AAKH;;AACD,QAAIK,MAAM,CAACoB,IAAP,CAAYC,WAAZ,CAAwBJ,MAAM,CAACE,OAA/B,CAAJ,EAA6C;AACzCF,MAAAA,MAAM,CAACE,OAAP,CAAeI,OAAf,CAAwB5B,KAAD,IAAW;AAC9B,YAAI,OAAOA,KAAP,IAAgB,QAApB,EAA8B;AAC1BwB,UAAAA,OAAO,CAACK,IAAR,CAAa7B,KAAb;AACH;AACJ,OAJD;AAKH;;AACD,QAAI,OAAOsB,MAAM,CAACQ,KAAd,IAAuB,QAA3B,EAAqC;AACjCN,MAAAA,OAAO,CAACK,IAAR,CAAaP,MAAM,CAACQ,KAApB;AACH;;AACD,QAAIC,eAAe,GAAG,EAAtB;;AACA,QAAI,OAAOT,MAAM,CAACU,gBAAd,IAAkC,QAAlC,IAA8CV,MAAM,CAACU,gBAAzD,EAA2E;AACvE,YAAMC,MAAM,GAAG,CAAC,GAAGxB,MAAM,CAACyB,OAAX,EAAoB,CAAC,GAAGzB,MAAM,CAAC0B,OAAX,EAAoBf,QAApB,CAApB,EAAmDE,MAAM,CAACU,gBAA1D,CAAf;;AACA,UAAI;AACAD,QAAAA,eAAe,GAAG,CAAC,GAAGvB,IAAI,CAAC4B,YAAT,EAAuBH,MAAvB,EAA+B,OAA/B,CAAlB;AACH,OAFD,CAGA,OAAOI,CAAP,EAAU;AACN,cAAM,IAAIjC,wBAAJ,CAA6B6B,MAA7B,EAAqCnB,IAArC,CAAN;AACH;AACJ;;AACD,QAAIwB,UAAU,GAAG,EAAjB;;AACA,QAAI,OAAOhB,MAAM,CAACiB,WAAd,IAA6B,QAA7B,IAAyCjB,MAAM,CAACiB,WAApD,EAAiE;AAC7D,YAAMC,MAAM,GAAG,CAAC,GAAG/B,MAAM,CAACyB,OAAX,EAAoB,CAAC,GAAGzB,MAAM,CAAC0B,OAAX,EAAoBf,QAApB,CAApB,EAAmDE,MAAM,CAACiB,WAA1D,CAAf;;AACA,UAAI;AACAD,QAAAA,UAAU,GAAG,CAAC,GAAG9B,IAAI,CAAC4B,YAAT,EAAuBI,MAAvB,EAA+B,OAA/B,CAAb;AACH,OAFD,CAGA,OAAOH,CAAP,EAAU;AACN,cAAM,IAAIjC,wBAAJ,CAA6BoC,MAA7B,EAAqC1B,IAArC,CAAN;AACH;AACJ;;AACD,UAAM2B,WAAW,GAAG,MAAMnB,MAAM,CAACmB,WAAP,KAAuBC,SAAvB,GAAmC,EAAnC,GAAwCpB,MAAM,CAACmB,WAArD,CAApB;AACA,WAAO;AACH3B,MAAAA,IADG;AAEH2B,MAAAA,WAFG;AAGH,UAAIV,eAAe,GAAG;AAAEA,QAAAA;AAAF,OAAH,GAAyB,EAA5C,CAHG;AAIH,UAAIO,UAAU,GAAG;AAAEA,QAAAA;AAAF,OAAH,GAAoB,EAAlC,CAJG;AAKHf,MAAAA,OALG;AAMHC,MAAAA;AANG,KAAP;AAQH,G;;;;AACDzB,OAAO,CAACI,sCAAR,GAAiDA,sCAAjD;;SACeD,mC;;;;;2DAAf,WAAmDY,IAAnD,EAAyDM,QAAzD,EAAmEC,QAAnE,EAA6EC,MAA7E,EAAqF;AACjF,UAAMqB,UAAU,SAASxC,sCAAsC,CAACW,IAAD,EAAOM,QAAP,EAAiBC,QAAjB,EAA2BC,MAA3B,CAA/D,CADiF,CAEjF;;AACA,QAAI,OAAOA,MAAM,CAACsB,KAAd,IAAuB,QAA3B,EAAqC;AACjC,YAAM,IAAIC,KAAJ,CAAW,WAAU/B,IAAK,iCAA1B,CAAN;AACH;;AACD,UAAMgC,GAAG,GAAG,IAAIvC,OAAO,CAACwC,eAAZ,CAA4BzB,MAAM,CAACsB,KAAnC,EAA0C,CAAC,GAAGnC,MAAM,CAAC0B,OAAX,EAAoBf,QAApB,CAA1C,CAAZ;AACA,UAAM4B,IAAI,GAAGF,GAAG,CAACA,GAAjB;;AACA,QAAIE,IAAI,KAAKN,SAAT,IAAsB,OAAOM,IAAP,KAAgB,UAA1C,EAAsD;AAClD,YAAM,IAAIH,KAAJ,CAAW,WAAU/B,IAAK,iCAA1B,CAAN;AACH;;AACD,UAAMmC,KAAK,GAAGlC,iBAAiB,CAACO,MAAM,CAAC4B,MAAR,EAAgBxC,WAAW,CAACyC,YAA5B,EAA0CzC,WAAW,CAACyC,YAAZ,CAAyBC,OAAnE,CAA/B;;AACA,UAAMC,MAAM,GAAG,CAAC,CAAC/B,MAAM,CAACgC,OAAxB;AACA,WAAO,EACH,GAAGX,UADA;AAEHM,MAAAA,KAFG;AAGHI,MAAAA,MAHG;AAIHL,MAAAA;AAJG,KAAP;AAMH,G;;;;AACDjD,OAAO,CAACG,mCAAR,GAA8CA,mCAA9C;;SACeD,wB;;;;;gDAAf,WAAwCoB,QAAxC,EAAkDC,MAAlD,EAA0D;AACtD,UAAMC,OAAO,GAAG,EAAhB;;AACA,aAASgC,OAAT,CAAiBC,OAAjB,EAA0BC,OAA1B,EAAmCC,YAAnC,EAAiD;AAC7C,UAAI,CAACA,YAAL,EAAmB;AACf;AACA;AACH,OAHD,MAIK,IAAID,OAAO,CAACE,KAAR,CAAc,uCAAd,EAAuDC,MAAvD,GAAgE,CAApE,EAAuE;AACxE;AACA;AACH,OAHI,MAIA,IAAIvD,MAAM,CAACoB,IAAP,CAAYC,WAAZ,CAAwB8B,OAAxB,CAAJ,EAAsC;AACvC;AACH;;AACD,UAAIC,OAAO,CAACI,OAAR,CAAgB,OAAhB,KAA4B,CAAC,CAAjC,EAAoC;AAChC;AACA,cAAM,IAAIhB,KAAJ,CAAU,oDAAV,CAAN;AACH;;AACD,YAAMiB,GAAG,GAAGzD,MAAM,CAACoB,IAAP,CAAYH,MAAZ,CAAmByC,gBAAnB,CAAoCN,OAApC,CAAZ;AACA,YAAM3C,IAAI,GAAGgD,GAAG,CAACA,GAAG,CAACF,MAAJ,GAAa,CAAd,CAAhB;;AACA,UAAIE,GAAG,CAACA,GAAG,CAACF,MAAJ,GAAa,CAAd,CAAH,IAAuB,YAA3B,EAAyC;AACrC;AACA;AACH;;AACD,YAAMI,OAAO,GAAG3D,MAAM,CAACoB,IAAP,CAAYH,MAAZ,CAAmB2C,gBAAnB,CAAoCT,OAApC,CAAhB;;AACA,UAAIQ,OAAO,CAACE,IAAR,IAAgB,CAApB,EAAuB;AACnB,cAAM,IAAIrB,KAAJ,CAAU,6BAAV,CAAN;AACH,OAzB4C,CA0B7C;;;AACA,YAAMsB,KAAK,GAAG,CAAC,GAAGH,OAAJ,EACTI,MADS,CACDC,CAAD,IAAO;AACf,gBAAQA,CAAR;AACI,eAAK,SAAL;AACA,eAAK,QAAL;AACA,eAAK,QAAL;AACI,mBAAO,IAAP;;AACJ,eAAK,OAAL;AACI;AACA,gBAAIhE,MAAM,CAACoB,IAAP,CAAY6C,YAAZ,CAAyBd,OAAO,CAACe,KAAjC,KACA,OAAOf,OAAO,CAACe,KAAR,CAAcC,IAArB,IAA6B,QAD7B,IAEA,CAAC,SAAD,EAAY,QAAZ,EAAsB,QAAtB,EAAgCrD,QAAhC,CAAyCqC,OAAO,CAACe,KAAR,CAAcC,IAAvD,CAFJ,EAEkE;AAC9D,qBAAO,IAAP;AACH;;AACD,mBAAO,KAAP;;AACJ;AACI,mBAAO,KAAP;AAdR;AAgBH,OAlBa,EAmBTC,GAnBS,CAmBJJ,CAAD,IAAOtD,iBAAiB,CAACsD,CAAD,EAAI3D,WAAW,CAACgE,UAAhB,EAA4BhE,WAAW,CAACgE,UAAZ,CAAuBC,MAAnD,CAnBnB,CAAd;;AAoBA,UAAIR,KAAK,CAACP,MAAN,IAAgB,CAApB,EAAuB;AACnB;AACA;AACH,OAlD4C,CAmD7C;;;AACA,YAAMgB,UAAU,GAAG,CAAEvE,MAAM,CAACoB,IAAP,CAAYC,WAAZ,CAAwB8B,OAAO,CAACqB,IAAhC,KAAyCrB,OAAO,CAACqB,IAAlD,IAA2D,EAA5D,EAAgET,MAAhE,CAAwEC,CAAD,IAAO;AAC7F,gBAAQ,OAAOA,CAAf;AACI,eAAK,SAAL;AACA,eAAK,QAAL;AACA,eAAK,QAAL;AACI,mBAAO,IAAP;;AACJ;AACI,mBAAO,KAAP;AANR;AAQH,OATkB,CAAnB;AAUA,UAAIpD,YAAY,GAAGyB,SAAnB;;AACA,UAAIc,OAAO,CAACsB,OAAR,KAAoBpC,SAAxB,EAAmC;AAC/B,gBAAQyB,KAAK,CAAC,CAAD,CAAb;AACI,eAAK,QAAL;AACI,gBAAI,OAAOX,OAAO,CAACsB,OAAf,IAA0B,QAA9B,EAAwC;AACpC7D,cAAAA,YAAY,GAAGuC,OAAO,CAACsB,OAAvB;AACH;;AACD;;AACJ,eAAK,QAAL;AACI,gBAAI,OAAOtB,OAAO,CAACsB,OAAf,IAA0B,QAA9B,EAAwC;AACpC7D,cAAAA,YAAY,GAAGuC,OAAO,CAACsB,OAAvB;AACH;;AACD;;AACJ,eAAK,SAAL;AACI,gBAAI,OAAOtB,OAAO,CAACsB,OAAf,IAA0B,SAA9B,EAAyC;AACrC7D,cAAAA,YAAY,GAAGuC,OAAO,CAACsB,OAAvB;AACH;;AACD;AAfR;AAiBH;;AACD,YAAMN,IAAI,GAAGL,KAAK,CAAC,CAAD,CAAlB;AACA,YAAMY,QAAQ,GAAGvB,OAAO,CAACuB,QAAzB;AACA,YAAMC,aAAa,GAAG3E,MAAM,CAACoB,IAAP,CAAY6C,YAAZ,CAAyBS,QAAzB,KAAsCA,QAAQ,CAAC,SAAD,CAAR,IAAuB,MAA7D,GAAsEA,QAAQ,CAAC,OAAD,CAA9E,GAA0FrC,SAAhH;AACA,YAAMuC,UAAU,GAAG,OAAOD,aAAP,IAAwB,QAAxB,GAAmCA,aAAnC,GAAmDtC,SAAtE;AACA,YAAMwC,QAAQ,GAAG7E,MAAM,CAACoB,IAAP,CAAYC,WAAZ,CAAwB8B,OAAO,CAAC0B,QAAhC,IACX1B,OAAO,CAAC0B,QAAR,CAAiBrB,OAAjB,CAAyB/C,IAAzB,KAAkC,CAAC,CADxB,GAEX,KAFN;AAGA,YAAMU,OAAO,GAAGnB,MAAM,CAACoB,IAAP,CAAYC,WAAZ,CAAwB8B,OAAO,CAAChC,OAAhC,IACV,CAAC,GAAGgC,OAAO,CAAChC,OAAZ,EAAqBiD,GAArB,CAA0BJ,CAAD,IAAO,KAAKA,CAArC,CADU,GAEVb,OAAO,CAAC1B,KAAR,GACI,CAAC,KAAK0B,OAAO,CAAC1B,KAAd,CADJ,GAEI,EAJV;AAKA,YAAMqD,MAAM,GAAG,OAAO3B,OAAO,CAAC2B,MAAf,IAAyB,QAAzB,GAAoC3B,OAAO,CAAC2B,MAA5C,GAAqDzC,SAApE;AACA,YAAM0C,OAAO,GAAG5B,OAAO,CAAC4B,OAAR,KAAoB1C,SAApB,IAAiCc,OAAO,CAAC4B,OAAR,KAAoB,IAArE;AACA,YAAM/B,MAAM,GAAG,CAAC,CAACG,OAAO,CAACH,MAAV,IAAoB,CAAC+B,OAApC;AACA,YAAMC,cAAc,GAAG7B,OAAO,CAAC,kBAAD,CAA9B;AACA,YAAM8B,aAAa,GAAG,OAAOD,cAAP,IAAyB,QAAzB,GAAoCA,cAApC,GAAqD3C,SAA3E,CAlG6C,CAmG7C;;AACA,YAAM6C,WAAW,GAAG/B,OAAO,CAAC,cAAD,CAA3B;AACA,YAAMgC,UAAU,GAAGD,WAAW,KAAK,IAAhB,IAAwB,OAAOA,WAAP,KAAuB,QAA/C,GAA0DA,WAA1D,GAAwE7C,SAA3F;AACA,YAAM+C,MAAM,GAAG;AACX3E,QAAAA,IADW;AAEX2B,QAAAA,WAAW,EAAE,MAAMe,OAAO,CAACf,WAAR,KAAwBC,SAAxB,GAAoC,EAApC,GAAyCc,OAAO,CAACf,WAAvD,CAFF;AAGX,YAAI0B,KAAK,CAACP,MAAN,IAAgB,CAAhB,GAAoB;AAAEY,UAAAA;AAAF,SAApB,GAA+B;AAAEA,UAAAA,IAAF;AAAQL,UAAAA;AAAR,SAAnC,CAHW;AAIX,YAAIlD,YAAY,KAAKyB,SAAjB,GAA6B;AAAEoC,UAAAA,OAAO,EAAE7D;AAAX,SAA7B,GAAyD,EAA7D,CAJW;AAKX,YAAI2D,UAAU,IAAIA,UAAU,CAAChB,MAAX,GAAoB,CAAlC,GAAsC;AAAEiB,UAAAA,IAAI,EAAED;AAAR,SAAtC,GAA6D,EAAjE,CALW;AAMXM,QAAAA,QANW;AAOX1D,QAAAA,OAPW;AAQX,YAAI2D,MAAM,KAAKzC,SAAX,GAAuB;AAAEyC,UAAAA;AAAF,SAAvB,GAAoC,EAAxC,CARW;AASX9B,QAAAA,MATW;AAUX,YAAIiC,aAAa,GAAG;AAAEA,UAAAA;AAAF,SAAH,GAAuB,EAAxC,CAVW;AAWX,YAAIE,UAAU,KAAK9C,SAAf,GAA2B;AAAE8C,UAAAA;AAAF,SAA3B,GAA4C,EAAhD,CAXW;AAYX,YAAIP,UAAU,KAAKvC,SAAf,GAA2B;AAAEuC,UAAAA;AAAF,SAA3B,GAA4C,EAAhD;AAZW,OAAf;AAcA1D,MAAAA,OAAO,CAACM,IAAR,CAAa4D,MAAb;AACH;;AACD,UAAMC,eAAe,SAASrE,QAAQ,CAACsE,OAAT,CAAiBrE,MAAjB,EAAyBsE,SAAzB,EAA9B;AACAvF,IAAAA,MAAM,CAACoB,IAAP,CAAYH,MAAZ,CAAmBuE,eAAnB,CAAmCH,eAAnC,EAAoDnC,OAApD,EAzHsD,CA0HtD;;AACA,WAAOhC,OAAO,CAACuE,IAAR,CAAa,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC1B,UAAID,CAAC,CAACd,UAAN,EAAkB;AACd,YAAIe,CAAC,CAACf,UAAN,EAAkB;AACd,iBAAOc,CAAC,CAACd,UAAF,GAAee,CAAC,CAACf,UAAxB;AACH,SAFD,MAGK;AACD,iBAAO,CAAP;AACH;AACJ,OAPD,MAQK,IAAIe,CAAC,CAACf,UAAN,EAAkB;AACnB,eAAO,CAAC,CAAR;AACH,OAFI,MAGA;AACD,eAAO,CAAP;AACH;AACJ,KAfM,CAAP;AAgBH,G;;;;AACDlF,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseJsonSchemaToOptions = exports.parseJsonSchemaToCommandDescription = exports.parseJsonSchemaToSubCommandDescription = exports.CommandJsonPathException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst tools_1 = require(\"@angular-devkit/schematics/tools\");\nconst fs_1 = require(\"fs\");\nconst path_1 = require(\"path\");\nconst interface_1 = require(\"../models/interface\");\nclass CommandJsonPathException extends core_1.BaseException {\n    constructor(path, name) {\n        super(`File ${path} was not found while constructing the subcommand ${name}.`);\n        this.path = path;\n        this.name = name;\n    }\n}\nexports.CommandJsonPathException = CommandJsonPathException;\nfunction _getEnumFromValue(value, enumeration, defaultValue) {\n    if (typeof value !== 'string') {\n        return defaultValue;\n    }\n    if (Object.values(enumeration).includes(value)) {\n        return value;\n    }\n    return defaultValue;\n}\nasync function parseJsonSchemaToSubCommandDescription(name, jsonPath, registry, schema) {\n    const options = await parseJsonSchemaToOptions(registry, schema);\n    const aliases = [];\n    if (core_1.json.isJsonArray(schema.$aliases)) {\n        schema.$aliases.forEach((value) => {\n            if (typeof value == 'string') {\n                aliases.push(value);\n            }\n        });\n    }\n    if (core_1.json.isJsonArray(schema.aliases)) {\n        schema.aliases.forEach((value) => {\n            if (typeof value == 'string') {\n                aliases.push(value);\n            }\n        });\n    }\n    if (typeof schema.alias == 'string') {\n        aliases.push(schema.alias);\n    }\n    let longDescription = '';\n    if (typeof schema.$longDescription == 'string' && schema.$longDescription) {\n        const ldPath = (0, path_1.resolve)((0, path_1.dirname)(jsonPath), schema.$longDescription);\n        try {\n            longDescription = (0, fs_1.readFileSync)(ldPath, 'utf-8');\n        }\n        catch (e) {\n            throw new CommandJsonPathException(ldPath, name);\n        }\n    }\n    let usageNotes = '';\n    if (typeof schema.$usageNotes == 'string' && schema.$usageNotes) {\n        const unPath = (0, path_1.resolve)((0, path_1.dirname)(jsonPath), schema.$usageNotes);\n        try {\n            usageNotes = (0, fs_1.readFileSync)(unPath, 'utf-8');\n        }\n        catch (e) {\n            throw new CommandJsonPathException(unPath, name);\n        }\n    }\n    const description = '' + (schema.description === undefined ? '' : schema.description);\n    return {\n        name,\n        description,\n        ...(longDescription ? { longDescription } : {}),\n        ...(usageNotes ? { usageNotes } : {}),\n        options,\n        aliases,\n    };\n}\nexports.parseJsonSchemaToSubCommandDescription = parseJsonSchemaToSubCommandDescription;\nasync function parseJsonSchemaToCommandDescription(name, jsonPath, registry, schema) {\n    const subcommand = await parseJsonSchemaToSubCommandDescription(name, jsonPath, registry, schema);\n    // Before doing any work, let's validate the implementation.\n    if (typeof schema.$impl != 'string') {\n        throw new Error(`Command ${name} has an invalid implementation.`);\n    }\n    const ref = new tools_1.ExportStringRef(schema.$impl, (0, path_1.dirname)(jsonPath));\n    const impl = ref.ref;\n    if (impl === undefined || typeof impl !== 'function') {\n        throw new Error(`Command ${name} has an invalid implementation.`);\n    }\n    const scope = _getEnumFromValue(schema.$scope, interface_1.CommandScope, interface_1.CommandScope.Default);\n    const hidden = !!schema.$hidden;\n    return {\n        ...subcommand,\n        scope,\n        hidden,\n        impl,\n    };\n}\nexports.parseJsonSchemaToCommandDescription = parseJsonSchemaToCommandDescription;\nasync function parseJsonSchemaToOptions(registry, schema) {\n    const options = [];\n    function visitor(current, pointer, parentSchema) {\n        if (!parentSchema) {\n            // Ignore root.\n            return;\n        }\n        else if (pointer.split(/\\/(?:properties|items|definitions)\\//g).length > 2) {\n            // Ignore subitems (objects or arrays).\n            return;\n        }\n        else if (core_1.json.isJsonArray(current)) {\n            return;\n        }\n        if (pointer.indexOf('/not/') != -1) {\n            // We don't support anyOf/not.\n            throw new Error('The \"not\" keyword is not supported in JSON Schema.');\n        }\n        const ptr = core_1.json.schema.parseJsonPointer(pointer);\n        const name = ptr[ptr.length - 1];\n        if (ptr[ptr.length - 2] != 'properties') {\n            // Skip any non-property items.\n            return;\n        }\n        const typeSet = core_1.json.schema.getTypesOfSchema(current);\n        if (typeSet.size == 0) {\n            throw new Error('Cannot find type of schema.');\n        }\n        // We only support number, string or boolean (or array of those), so remove everything else.\n        const types = [...typeSet]\n            .filter((x) => {\n            switch (x) {\n                case 'boolean':\n                case 'number':\n                case 'string':\n                    return true;\n                case 'array':\n                    // Only include arrays if they're boolean, string or number.\n                    if (core_1.json.isJsonObject(current.items) &&\n                        typeof current.items.type == 'string' &&\n                        ['boolean', 'number', 'string'].includes(current.items.type)) {\n                        return true;\n                    }\n                    return false;\n                default:\n                    return false;\n            }\n        })\n            .map((x) => _getEnumFromValue(x, interface_1.OptionType, interface_1.OptionType.String));\n        if (types.length == 0) {\n            // This means it's not usable on the command line. e.g. an Object.\n            return;\n        }\n        // Only keep enum values we support (booleans, numbers and strings).\n        const enumValues = ((core_1.json.isJsonArray(current.enum) && current.enum) || []).filter((x) => {\n            switch (typeof x) {\n                case 'boolean':\n                case 'number':\n                case 'string':\n                    return true;\n                default:\n                    return false;\n            }\n        });\n        let defaultValue = undefined;\n        if (current.default !== undefined) {\n            switch (types[0]) {\n                case 'string':\n                    if (typeof current.default == 'string') {\n                        defaultValue = current.default;\n                    }\n                    break;\n                case 'number':\n                    if (typeof current.default == 'number') {\n                        defaultValue = current.default;\n                    }\n                    break;\n                case 'boolean':\n                    if (typeof current.default == 'boolean') {\n                        defaultValue = current.default;\n                    }\n                    break;\n            }\n        }\n        const type = types[0];\n        const $default = current.$default;\n        const $defaultIndex = core_1.json.isJsonObject($default) && $default['$source'] == 'argv' ? $default['index'] : undefined;\n        const positional = typeof $defaultIndex == 'number' ? $defaultIndex : undefined;\n        const required = core_1.json.isJsonArray(current.required)\n            ? current.required.indexOf(name) != -1\n            : false;\n        const aliases = core_1.json.isJsonArray(current.aliases)\n            ? [...current.aliases].map((x) => '' + x)\n            : current.alias\n                ? ['' + current.alias]\n                : [];\n        const format = typeof current.format == 'string' ? current.format : undefined;\n        const visible = current.visible === undefined || current.visible === true;\n        const hidden = !!current.hidden || !visible;\n        const xUserAnalytics = current['x-user-analytics'];\n        const userAnalytics = typeof xUserAnalytics == 'number' ? xUserAnalytics : undefined;\n        // Deprecated is set only if it's true or a string.\n        const xDeprecated = current['x-deprecated'];\n        const deprecated = xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : undefined;\n        const option = {\n            name,\n            description: '' + (current.description === undefined ? '' : current.description),\n            ...(types.length == 1 ? { type } : { type, types }),\n            ...(defaultValue !== undefined ? { default: defaultValue } : {}),\n            ...(enumValues && enumValues.length > 0 ? { enum: enumValues } : {}),\n            required,\n            aliases,\n            ...(format !== undefined ? { format } : {}),\n            hidden,\n            ...(userAnalytics ? { userAnalytics } : {}),\n            ...(deprecated !== undefined ? { deprecated } : {}),\n            ...(positional !== undefined ? { positional } : {}),\n        };\n        options.push(option);\n    }\n    const flattenedSchema = await registry.flatten(schema).toPromise();\n    core_1.json.schema.visitJsonSchema(flattenedSchema, visitor);\n    // Sort by positional.\n    return options.sort((a, b) => {\n        if (a.positional) {\n            if (b.positional) {\n                return a.positional - b.positional;\n            }\n            else {\n                return 1;\n            }\n        }\n        else if (b.positional) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    });\n}\nexports.parseJsonSchemaToOptions = parseJsonSchemaToOptions;\n"]},"metadata":{},"sourceType":"script"}