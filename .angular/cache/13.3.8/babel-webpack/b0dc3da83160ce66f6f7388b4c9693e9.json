{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeJsonWorkspace = void 0;\n\nconst magic_string_1 = __importDefault(require(\"magic-string\"));\n\nconst metadata_1 = require(\"./metadata\");\n\nconst utilities_1 = require(\"./utilities\");\n\nfunction writeJsonWorkspace(_x, _x2, _x3) {\n  return _writeJsonWorkspace.apply(this, arguments);\n}\n\nfunction _writeJsonWorkspace() {\n  _writeJsonWorkspace = _asyncToGenerator(function* (workspace, host, path, options = {}) {\n    const metadata = workspace[metadata_1.JsonWorkspaceSymbol];\n\n    if (metadata) {\n      if (!metadata.hasChanges) {\n        // nothing to do\n        return;\n      } // update existing JSON workspace\n\n\n      const data = updateJsonWorkspace(metadata);\n      return host.writeFile(path || metadata.filePath, data);\n    } else {\n      // serialize directly\n      if (!path) {\n        throw new Error('path option is required');\n      }\n\n      const obj = convertJsonWorkspace(workspace, options.schema);\n      const data = JSON.stringify(obj, null, 2);\n      return host.writeFile(path, data);\n    }\n  });\n  return _writeJsonWorkspace.apply(this, arguments);\n}\n\nexports.writeJsonWorkspace = writeJsonWorkspace;\n\nfunction convertJsonWorkspace(workspace, schema) {\n  const obj = {\n    $schema: schema || './node_modules/@angular/cli/lib/config/schema.json',\n    version: 1,\n    ...workspace.extensions,\n    projects: workspace.projects ? convertJsonProjectCollection(workspace.projects) : {}\n  };\n  return obj;\n}\n\nfunction convertJsonProjectCollection(collection) {\n  const projects = Object.create(null);\n\n  for (const [projectName, project] of collection) {\n    projects[projectName] = convertJsonProject(project);\n  }\n\n  return projects;\n}\n\nfunction convertJsonProject(project) {\n  let targets;\n\n  if (project.targets.size > 0) {\n    targets = Object.create(null);\n\n    for (const [targetName, target] of project.targets) {\n      targets[targetName] = convertJsonTarget(target);\n    }\n  }\n\n  const obj = { ...project.extensions,\n    root: project.root,\n    ...(project.sourceRoot === undefined ? {} : {\n      sourceRoot: project.sourceRoot\n    }),\n    ...(project.prefix === undefined ? {} : {\n      prefix: project.prefix\n    }),\n    ...(targets === undefined ? {} : {\n      architect: targets\n    })\n  };\n  return obj;\n}\n\nfunction isEmpty(obj) {\n  return obj === undefined || Object.keys(obj).length === 0;\n}\n\nfunction convertJsonTarget(target) {\n  return {\n    builder: target.builder,\n    ...(isEmpty(target.options) ? {} : {\n      options: target.options\n    }),\n    ...(isEmpty(target.configurations) ? {} : {\n      configurations: target.configurations\n    }),\n    ...(target.defaultConfiguration === undefined ? {} : {\n      defaultConfiguration: target.defaultConfiguration\n    })\n  };\n}\n\nfunction convertJsonTargetCollection(collection) {\n  const targets = Object.create(null);\n\n  for (const [projectName, target] of collection) {\n    targets[projectName] = convertJsonTarget(target);\n  }\n\n  return targets;\n}\n\nfunction findFullStart(node, raw) {\n  let i = node.start.offset;\n\n  while (i > 0 && /\\s/.test(raw[i - 1])) {\n    --i;\n  }\n\n  return i;\n}\n\nfunction findFullEnd(node, raw) {\n  let i = node.end.offset;\n\n  if (i >= raw.length) {\n    return raw.length;\n  } else if (raw[i] === ',') {\n    return i + 1;\n  }\n\n  while (i > node.start.offset && /\\s/.test(raw[i - 1])) {\n    --i;\n  }\n\n  return i;\n}\n\nfunction findPrecedingComma(node, raw) {\n  let i = node.start.offset;\n\n  if (node.comments && node.comments.length > 0) {\n    i = node.comments[0].start.offset;\n  }\n\n  while (i > 0 && /\\s/.test(raw[i - 1])) {\n    --i;\n  }\n\n  if (raw[i - 1] === ',') {\n    return i - 1;\n  }\n\n  return -1;\n}\n\nfunction stringify(value, multiline, depth, indent) {\n  if (value === undefined) {\n    return '';\n  }\n\n  if (multiline) {\n    const content = JSON.stringify(value, null, indent);\n    const spacing = '\\n' + indent.repeat(depth);\n    return content.replace(/\\n/g, spacing);\n  } else {\n    return JSON.stringify(value);\n  }\n}\n\nfunction normalizeValue(value, type) {\n  switch (type) {\n    case 'project':\n      return convertJsonProject(value);\n\n    case 'projectcollection':\n      const projects = convertJsonProjectCollection(value);\n      return Object.keys(projects).length === 0 ? undefined : projects;\n\n    case 'target':\n      return convertJsonTarget(value);\n\n    case 'targetcollection':\n      const targets = convertJsonTargetCollection(value);\n      return Object.keys(targets).length === 0 ? undefined : targets;\n\n    default:\n      return value;\n  }\n}\n\nfunction updateJsonWorkspace(metadata) {\n  const data = new magic_string_1.default(metadata.raw);\n  const indent = data.getIndentString();\n  const removedCommas = new Set();\n  const nodeChanges = new Map();\n\n  for (const {\n    op,\n    path,\n    node,\n    value,\n    type\n  } of metadata.changes) {\n    // targets/projects are typically large objects so always use multiline\n    const multiline = node.start.line !== node.end.line || type !== 'json';\n    const pathSegments = path.split('/');\n    const depth = pathSegments.length - 1; // TODO: more complete analysis\n\n    const propertyOrIndex = (0, utilities_1.unescapeKey)(pathSegments[depth]);\n    const jsonValue = normalizeValue(value, type);\n\n    if (op === 'add' && jsonValue === undefined) {\n      continue;\n    } // Track changes to the order/size of any modified objects/arrays\n\n\n    let elements = nodeChanges.get(node);\n\n    if (!elements) {\n      if (node.kind === 'array') {\n        elements = node.elements.slice();\n        nodeChanges.set(node, elements);\n      } else if (node.kind === 'object') {\n        elements = node.properties.slice();\n        nodeChanges.set(node, elements);\n      } else {\n        // keyvalue\n        elements = [];\n      }\n    }\n\n    switch (op) {\n      case 'add':\n        let contentPrefix = '';\n\n        if (node.kind === 'object') {\n          contentPrefix = `\"${propertyOrIndex}\": `;\n        }\n\n        const spacing = multiline ? '\\n' + indent.repeat(depth) : ' ';\n        const content = spacing + contentPrefix + stringify(jsonValue, multiline, depth, indent); // Additions are handled after analyzing all operations\n        // This is mainly to support array operations which can occur at arbitrary indices\n\n        if (node.kind === 'object') {\n          // Object property additions are always added at the end for simplicity\n          elements.push(content);\n        } else {\n          // Add place holders if adding an index past the length\n          // An empty string is an impossible real value\n          for (let i = elements.length; i < +propertyOrIndex; ++i) {\n            elements[i] = '';\n          }\n\n          if (elements[+propertyOrIndex] === '') {\n            elements[+propertyOrIndex] = content;\n          } else {\n            elements.splice(+propertyOrIndex, 0, content);\n          }\n        }\n\n        break;\n\n      case 'remove':\n        let removalIndex = -1;\n\n        if (node.kind === 'object') {\n          removalIndex = elements.findIndex(e => {\n            return typeof e != 'string' && e.kind === 'keyvalue' && e.key.value === propertyOrIndex;\n          });\n        } else if (node.kind === 'array') {\n          removalIndex = +propertyOrIndex;\n        }\n\n        if (removalIndex === -1) {\n          continue;\n        }\n\n        const nodeToRemove = elements[removalIndex];\n\n        if (typeof nodeToRemove === 'string') {\n          // synthetic\n          elements.splice(removalIndex, 1);\n          continue;\n        }\n\n        if (elements.length - 1 === removalIndex) {\n          // If the element is a terminal element remove the otherwise trailing comma\n          const commaIndex = findPrecedingComma(nodeToRemove, data.original);\n\n          if (commaIndex !== -1) {\n            data.remove(commaIndex, commaIndex + 1);\n            removedCommas.add(commaIndex);\n          }\n        }\n\n        data.remove(findFullStart(nodeToRemove, data.original), findFullEnd(nodeToRemove, data.original));\n        elements.splice(removalIndex, 1);\n        break;\n\n      case 'replace':\n        let nodeToReplace;\n\n        if (node.kind === 'keyvalue') {\n          nodeToReplace = node.value;\n        } else if (node.kind === 'array') {\n          nodeToReplace = elements[+propertyOrIndex];\n\n          if (typeof nodeToReplace === 'string') {\n            // Was already modified. This is already handled.\n            continue;\n          }\n        } else {\n          continue;\n        }\n\n        nodeChanges.delete(nodeToReplace);\n        data.overwrite(nodeToReplace.start.offset, nodeToReplace.end.offset, stringify(jsonValue, multiline, depth, indent));\n        break;\n    }\n  }\n\n  for (const [node, elements] of nodeChanges.entries()) {\n    let parentPoint = 1 + data.original.indexOf(node.kind === 'array' ? '[' : '{', node.start.offset); // Short-circuit for simple case\n\n    if (elements.length === 1 && typeof elements[0] === 'string') {\n      data.appendRight(parentPoint, elements[0]);\n      continue;\n    } // Combine adjecent element additions to minimize/simplify insertions\n\n\n    const optimizedElements = [];\n\n    for (let i = 0; i < elements.length; ++i) {\n      const element = elements[i];\n\n      if (typeof element === 'string' && i > 0 && typeof elements[i - 1] === 'string') {\n        optimizedElements[optimizedElements.length - 1] += ',' + element;\n      } else {\n        optimizedElements.push(element);\n      }\n    }\n\n    let prefixComma = false;\n\n    for (const element of optimizedElements) {\n      if (typeof element === 'string') {\n        data.appendRight(parentPoint, (prefixComma ? ',' : '') + element);\n      } else {\n        parentPoint = findFullEnd(element, data.original);\n        prefixComma = data.original[parentPoint - 1] !== ',' || removedCommas.has(parentPoint - 1);\n      }\n    }\n  }\n\n  const result = data.toString();\n  return result;\n}","map":{"version":3,"sources":["/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@angular-devkit/core/src/workspace/json/writer.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","writeJsonWorkspace","magic_string_1","require","metadata_1","utilities_1","workspace","host","path","options","metadata","JsonWorkspaceSymbol","hasChanges","data","updateJsonWorkspace","writeFile","filePath","Error","obj","convertJsonWorkspace","schema","JSON","stringify","$schema","version","extensions","projects","convertJsonProjectCollection","collection","create","projectName","project","convertJsonProject","targets","size","targetName","target","convertJsonTarget","root","sourceRoot","undefined","prefix","architect","isEmpty","keys","length","builder","configurations","defaultConfiguration","convertJsonTargetCollection","findFullStart","node","raw","i","start","offset","test","findFullEnd","end","findPrecedingComma","comments","multiline","depth","indent","content","spacing","repeat","replace","normalizeValue","type","default","getIndentString","removedCommas","Set","nodeChanges","Map","op","changes","line","pathSegments","split","propertyOrIndex","unescapeKey","jsonValue","elements","get","kind","slice","set","properties","contentPrefix","push","splice","removalIndex","findIndex","e","key","nodeToRemove","commaIndex","original","remove","add","nodeToReplace","delete","overwrite","entries","parentPoint","indexOf","appendRight","optimizedElements","element","prefixComma","has","result","toString"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeJsonWorkspace = void 0;\nconst magic_string_1 = __importDefault(require(\"magic-string\"));\nconst metadata_1 = require(\"./metadata\");\nconst utilities_1 = require(\"./utilities\");\nasync function writeJsonWorkspace(workspace, host, path, options = {}) {\n    const metadata = workspace[metadata_1.JsonWorkspaceSymbol];\n    if (metadata) {\n        if (!metadata.hasChanges) {\n            // nothing to do\n            return;\n        }\n        // update existing JSON workspace\n        const data = updateJsonWorkspace(metadata);\n        return host.writeFile(path || metadata.filePath, data);\n    }\n    else {\n        // serialize directly\n        if (!path) {\n            throw new Error('path option is required');\n        }\n        const obj = convertJsonWorkspace(workspace, options.schema);\n        const data = JSON.stringify(obj, null, 2);\n        return host.writeFile(path, data);\n    }\n}\nexports.writeJsonWorkspace = writeJsonWorkspace;\nfunction convertJsonWorkspace(workspace, schema) {\n    const obj = {\n        $schema: schema || './node_modules/@angular/cli/lib/config/schema.json',\n        version: 1,\n        ...workspace.extensions,\n        projects: workspace.projects ? convertJsonProjectCollection(workspace.projects) : {},\n    };\n    return obj;\n}\nfunction convertJsonProjectCollection(collection) {\n    const projects = Object.create(null);\n    for (const [projectName, project] of collection) {\n        projects[projectName] = convertJsonProject(project);\n    }\n    return projects;\n}\nfunction convertJsonProject(project) {\n    let targets;\n    if (project.targets.size > 0) {\n        targets = Object.create(null);\n        for (const [targetName, target] of project.targets) {\n            targets[targetName] = convertJsonTarget(target);\n        }\n    }\n    const obj = {\n        ...project.extensions,\n        root: project.root,\n        ...(project.sourceRoot === undefined ? {} : { sourceRoot: project.sourceRoot }),\n        ...(project.prefix === undefined ? {} : { prefix: project.prefix }),\n        ...(targets === undefined ? {} : { architect: targets }),\n    };\n    return obj;\n}\nfunction isEmpty(obj) {\n    return obj === undefined || Object.keys(obj).length === 0;\n}\nfunction convertJsonTarget(target) {\n    return {\n        builder: target.builder,\n        ...(isEmpty(target.options) ? {} : { options: target.options }),\n        ...(isEmpty(target.configurations)\n            ? {}\n            : { configurations: target.configurations }),\n        ...(target.defaultConfiguration === undefined\n            ? {}\n            : { defaultConfiguration: target.defaultConfiguration }),\n    };\n}\nfunction convertJsonTargetCollection(collection) {\n    const targets = Object.create(null);\n    for (const [projectName, target] of collection) {\n        targets[projectName] = convertJsonTarget(target);\n    }\n    return targets;\n}\nfunction findFullStart(node, raw) {\n    let i = node.start.offset;\n    while (i > 0 && /\\s/.test(raw[i - 1])) {\n        --i;\n    }\n    return i;\n}\nfunction findFullEnd(node, raw) {\n    let i = node.end.offset;\n    if (i >= raw.length) {\n        return raw.length;\n    }\n    else if (raw[i] === ',') {\n        return i + 1;\n    }\n    while (i > node.start.offset && /\\s/.test(raw[i - 1])) {\n        --i;\n    }\n    return i;\n}\nfunction findPrecedingComma(node, raw) {\n    let i = node.start.offset;\n    if (node.comments && node.comments.length > 0) {\n        i = node.comments[0].start.offset;\n    }\n    while (i > 0 && /\\s/.test(raw[i - 1])) {\n        --i;\n    }\n    if (raw[i - 1] === ',') {\n        return i - 1;\n    }\n    return -1;\n}\nfunction stringify(value, multiline, depth, indent) {\n    if (value === undefined) {\n        return '';\n    }\n    if (multiline) {\n        const content = JSON.stringify(value, null, indent);\n        const spacing = '\\n' + indent.repeat(depth);\n        return content.replace(/\\n/g, spacing);\n    }\n    else {\n        return JSON.stringify(value);\n    }\n}\nfunction normalizeValue(value, type) {\n    switch (type) {\n        case 'project':\n            return convertJsonProject(value);\n        case 'projectcollection':\n            const projects = convertJsonProjectCollection(value);\n            return Object.keys(projects).length === 0 ? undefined : projects;\n        case 'target':\n            return convertJsonTarget(value);\n        case 'targetcollection':\n            const targets = convertJsonTargetCollection(value);\n            return Object.keys(targets).length === 0 ? undefined : targets;\n        default:\n            return value;\n    }\n}\nfunction updateJsonWorkspace(metadata) {\n    const data = new magic_string_1.default(metadata.raw);\n    const indent = data.getIndentString();\n    const removedCommas = new Set();\n    const nodeChanges = new Map();\n    for (const { op, path, node, value, type } of metadata.changes) {\n        // targets/projects are typically large objects so always use multiline\n        const multiline = node.start.line !== node.end.line || type !== 'json';\n        const pathSegments = path.split('/');\n        const depth = pathSegments.length - 1; // TODO: more complete analysis\n        const propertyOrIndex = (0, utilities_1.unescapeKey)(pathSegments[depth]);\n        const jsonValue = normalizeValue(value, type);\n        if (op === 'add' && jsonValue === undefined) {\n            continue;\n        }\n        // Track changes to the order/size of any modified objects/arrays\n        let elements = nodeChanges.get(node);\n        if (!elements) {\n            if (node.kind === 'array') {\n                elements = node.elements.slice();\n                nodeChanges.set(node, elements);\n            }\n            else if (node.kind === 'object') {\n                elements = node.properties.slice();\n                nodeChanges.set(node, elements);\n            }\n            else {\n                // keyvalue\n                elements = [];\n            }\n        }\n        switch (op) {\n            case 'add':\n                let contentPrefix = '';\n                if (node.kind === 'object') {\n                    contentPrefix = `\"${propertyOrIndex}\": `;\n                }\n                const spacing = multiline ? '\\n' + indent.repeat(depth) : ' ';\n                const content = spacing + contentPrefix + stringify(jsonValue, multiline, depth, indent);\n                // Additions are handled after analyzing all operations\n                // This is mainly to support array operations which can occur at arbitrary indices\n                if (node.kind === 'object') {\n                    // Object property additions are always added at the end for simplicity\n                    elements.push(content);\n                }\n                else {\n                    // Add place holders if adding an index past the length\n                    // An empty string is an impossible real value\n                    for (let i = elements.length; i < +propertyOrIndex; ++i) {\n                        elements[i] = '';\n                    }\n                    if (elements[+propertyOrIndex] === '') {\n                        elements[+propertyOrIndex] = content;\n                    }\n                    else {\n                        elements.splice(+propertyOrIndex, 0, content);\n                    }\n                }\n                break;\n            case 'remove':\n                let removalIndex = -1;\n                if (node.kind === 'object') {\n                    removalIndex = elements.findIndex((e) => {\n                        return typeof e != 'string' && e.kind === 'keyvalue' && e.key.value === propertyOrIndex;\n                    });\n                }\n                else if (node.kind === 'array') {\n                    removalIndex = +propertyOrIndex;\n                }\n                if (removalIndex === -1) {\n                    continue;\n                }\n                const nodeToRemove = elements[removalIndex];\n                if (typeof nodeToRemove === 'string') {\n                    // synthetic\n                    elements.splice(removalIndex, 1);\n                    continue;\n                }\n                if (elements.length - 1 === removalIndex) {\n                    // If the element is a terminal element remove the otherwise trailing comma\n                    const commaIndex = findPrecedingComma(nodeToRemove, data.original);\n                    if (commaIndex !== -1) {\n                        data.remove(commaIndex, commaIndex + 1);\n                        removedCommas.add(commaIndex);\n                    }\n                }\n                data.remove(findFullStart(nodeToRemove, data.original), findFullEnd(nodeToRemove, data.original));\n                elements.splice(removalIndex, 1);\n                break;\n            case 'replace':\n                let nodeToReplace;\n                if (node.kind === 'keyvalue') {\n                    nodeToReplace = node.value;\n                }\n                else if (node.kind === 'array') {\n                    nodeToReplace = elements[+propertyOrIndex];\n                    if (typeof nodeToReplace === 'string') {\n                        // Was already modified. This is already handled.\n                        continue;\n                    }\n                }\n                else {\n                    continue;\n                }\n                nodeChanges.delete(nodeToReplace);\n                data.overwrite(nodeToReplace.start.offset, nodeToReplace.end.offset, stringify(jsonValue, multiline, depth, indent));\n                break;\n        }\n    }\n    for (const [node, elements] of nodeChanges.entries()) {\n        let parentPoint = 1 + data.original.indexOf(node.kind === 'array' ? '[' : '{', node.start.offset);\n        // Short-circuit for simple case\n        if (elements.length === 1 && typeof elements[0] === 'string') {\n            data.appendRight(parentPoint, elements[0]);\n            continue;\n        }\n        // Combine adjecent element additions to minimize/simplify insertions\n        const optimizedElements = [];\n        for (let i = 0; i < elements.length; ++i) {\n            const element = elements[i];\n            if (typeof element === 'string' && i > 0 && typeof elements[i - 1] === 'string') {\n                optimizedElements[optimizedElements.length - 1] += ',' + element;\n            }\n            else {\n                optimizedElements.push(element);\n            }\n        }\n        let prefixComma = false;\n        for (const element of optimizedElements) {\n            if (typeof element === 'string') {\n                data.appendRight(parentPoint, (prefixComma ? ',' : '') + element);\n            }\n            else {\n                parentPoint = findFullEnd(element, data.original);\n                prefixComma = data.original[parentPoint - 1] !== ',' || removedCommas.has(parentPoint - 1);\n            }\n        }\n    }\n    const result = data.toString();\n    return result;\n}\n"]},"metadata":{},"sourceType":"script"}