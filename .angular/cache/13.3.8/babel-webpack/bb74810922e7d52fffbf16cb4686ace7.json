{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeWorkspace = exports.readWorkspace = exports._test_removeWorkspaceFile = exports._test_addWorkspaceFile = exports.WorkspaceFormat = void 0;\n\nconst virtual_fs_1 = require(\"../virtual-fs\");\n\nconst reader_1 = require(\"./json/reader\");\n\nconst writer_1 = require(\"./json/writer\");\n\nconst formatLookup = new WeakMap();\n/**\n * Supported workspace formats\n */\n\nvar WorkspaceFormat;\n\n(function (WorkspaceFormat) {\n  WorkspaceFormat[WorkspaceFormat[\"JSON\"] = 0] = \"JSON\";\n})(WorkspaceFormat = exports.WorkspaceFormat || (exports.WorkspaceFormat = {}));\n/**\n * @private\n */\n\n\nfunction _test_addWorkspaceFile(name, format) {\n  workspaceFiles[name] = format;\n}\n\nexports._test_addWorkspaceFile = _test_addWorkspaceFile;\n/**\n * @private\n */\n\nfunction _test_removeWorkspaceFile(name) {\n  delete workspaceFiles[name];\n}\n\nexports._test_removeWorkspaceFile = _test_removeWorkspaceFile; // NOTE: future additions could also perform content analysis to determine format/version\n\nconst workspaceFiles = {\n  'angular.json': WorkspaceFormat.JSON,\n  '.angular.json': WorkspaceFormat.JSON\n};\n/**\n * Reads and constructs a `WorkspaceDefinition`.  If the function is provided with a path to a\n * directory instead of a file, a search of the directory's files will commence to attempt to\n * locate a known workspace file.  Currently the following are considered known workspace files:\n * - `angular.json`\n * - `.angular.json`\n *\n * @param path The path to either a workspace file or a directory containing a workspace file.\n * @param host The `WorkspaceHost` to use to access the file and directory data.\n * @param format An optional `WorkspaceFormat` value. Used if the path specifies a non-standard\n * file name that would prevent automatically discovering the format.\n *\n *\n * @return An `Promise` of the read result object with the `WorkspaceDefinition` contained within\n * the `workspace` property.\n */\n\nfunction readWorkspace(_x, _x2, _x3) {\n  return _readWorkspace.apply(this, arguments);\n}\n\nfunction _readWorkspace() {\n  _readWorkspace = _asyncToGenerator(function* (path, host, format) {\n    if (yield host.isDirectory(path)) {\n      // TODO: Warn if multiple found (requires diagnostics support)\n      const directory = (0, virtual_fs_1.normalize)(path);\n      let found = false;\n\n      for (const [name, nameFormat] of Object.entries(workspaceFiles)) {\n        if (format !== undefined && format !== nameFormat) {\n          continue;\n        }\n\n        const potential = (0, virtual_fs_1.getSystemPath)((0, virtual_fs_1.join)(directory, name));\n\n        if (yield host.isFile(potential)) {\n          path = potential;\n          format = nameFormat;\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        throw new Error('Unable to locate a workspace file for workspace path. Are you missing an `angular.json`' + ' or `.angular.json` file?');\n      }\n    } else if (format === undefined) {\n      const filename = (0, virtual_fs_1.basename)((0, virtual_fs_1.normalize)(path));\n\n      if (filename in workspaceFiles) {\n        format = workspaceFiles[filename];\n      }\n    }\n\n    if (format === undefined) {\n      throw new Error('Unable to determine format for workspace path.');\n    }\n\n    let workspace;\n\n    switch (format) {\n      case WorkspaceFormat.JSON:\n        workspace = yield (0, reader_1.readJsonWorkspace)(path, host);\n        break;\n\n      default:\n        throw new Error('Unsupported workspace format.');\n    }\n\n    formatLookup.set(workspace, WorkspaceFormat.JSON);\n    return {\n      workspace\n    };\n  });\n  return _readWorkspace.apply(this, arguments);\n}\n\nexports.readWorkspace = readWorkspace;\n/**\n * Writes a `WorkspaceDefinition` to the underlying storage via the provided `WorkspaceHost`.\n * If the `WorkspaceDefinition` was created via the `readWorkspace` function, metadata will be\n * used to determine the path and format of the Workspace.  In all other cases, the `path` and\n * `format` options must be specified as they would be otherwise unknown.\n *\n * @param workspace The `WorkspaceDefinition` that will be written.\n * @param host The `WorkspaceHost` to use to access/write the file and directory data.\n * @param path The path to a file location for the output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n * @param format The `WorkspaceFormat` to use for output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n *\n *\n * @return An `Promise` of type `void`.\n */\n\nfunction writeWorkspace(_x4, _x5, _x6, _x7) {\n  return _writeWorkspace.apply(this, arguments);\n}\n\nfunction _writeWorkspace() {\n  _writeWorkspace = _asyncToGenerator(function* (workspace, host, path, format) {\n    if (format === undefined) {\n      format = formatLookup.get(workspace);\n\n      if (format === undefined) {\n        throw new Error('A format is required for custom workspace objects.');\n      }\n    }\n\n    switch (format) {\n      case WorkspaceFormat.JSON:\n        return (0, writer_1.writeJsonWorkspace)(workspace, host, path);\n\n      default:\n        throw new Error('Unsupported workspace format.');\n    }\n  });\n  return _writeWorkspace.apply(this, arguments);\n}\n\nexports.writeWorkspace = writeWorkspace;","map":{"version":3,"sources":["/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@angular-devkit/core/src/workspace/core.js"],"names":["Object","defineProperty","exports","value","writeWorkspace","readWorkspace","_test_removeWorkspaceFile","_test_addWorkspaceFile","WorkspaceFormat","virtual_fs_1","require","reader_1","writer_1","formatLookup","WeakMap","name","format","workspaceFiles","JSON","path","host","isDirectory","directory","normalize","found","nameFormat","entries","undefined","potential","getSystemPath","join","isFile","Error","filename","basename","workspace","readJsonWorkspace","set","get","writeJsonWorkspace"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeWorkspace = exports.readWorkspace = exports._test_removeWorkspaceFile = exports._test_addWorkspaceFile = exports.WorkspaceFormat = void 0;\nconst virtual_fs_1 = require(\"../virtual-fs\");\nconst reader_1 = require(\"./json/reader\");\nconst writer_1 = require(\"./json/writer\");\nconst formatLookup = new WeakMap();\n/**\n * Supported workspace formats\n */\nvar WorkspaceFormat;\n(function (WorkspaceFormat) {\n    WorkspaceFormat[WorkspaceFormat[\"JSON\"] = 0] = \"JSON\";\n})(WorkspaceFormat = exports.WorkspaceFormat || (exports.WorkspaceFormat = {}));\n/**\n * @private\n */\nfunction _test_addWorkspaceFile(name, format) {\n    workspaceFiles[name] = format;\n}\nexports._test_addWorkspaceFile = _test_addWorkspaceFile;\n/**\n * @private\n */\nfunction _test_removeWorkspaceFile(name) {\n    delete workspaceFiles[name];\n}\nexports._test_removeWorkspaceFile = _test_removeWorkspaceFile;\n// NOTE: future additions could also perform content analysis to determine format/version\nconst workspaceFiles = {\n    'angular.json': WorkspaceFormat.JSON,\n    '.angular.json': WorkspaceFormat.JSON,\n};\n/**\n * Reads and constructs a `WorkspaceDefinition`.  If the function is provided with a path to a\n * directory instead of a file, a search of the directory's files will commence to attempt to\n * locate a known workspace file.  Currently the following are considered known workspace files:\n * - `angular.json`\n * - `.angular.json`\n *\n * @param path The path to either a workspace file or a directory containing a workspace file.\n * @param host The `WorkspaceHost` to use to access the file and directory data.\n * @param format An optional `WorkspaceFormat` value. Used if the path specifies a non-standard\n * file name that would prevent automatically discovering the format.\n *\n *\n * @return An `Promise` of the read result object with the `WorkspaceDefinition` contained within\n * the `workspace` property.\n */\nasync function readWorkspace(path, host, format) {\n    if (await host.isDirectory(path)) {\n        // TODO: Warn if multiple found (requires diagnostics support)\n        const directory = (0, virtual_fs_1.normalize)(path);\n        let found = false;\n        for (const [name, nameFormat] of Object.entries(workspaceFiles)) {\n            if (format !== undefined && format !== nameFormat) {\n                continue;\n            }\n            const potential = (0, virtual_fs_1.getSystemPath)((0, virtual_fs_1.join)(directory, name));\n            if (await host.isFile(potential)) {\n                path = potential;\n                format = nameFormat;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw new Error('Unable to locate a workspace file for workspace path. Are you missing an `angular.json`' +\n                ' or `.angular.json` file?');\n        }\n    }\n    else if (format === undefined) {\n        const filename = (0, virtual_fs_1.basename)((0, virtual_fs_1.normalize)(path));\n        if (filename in workspaceFiles) {\n            format = workspaceFiles[filename];\n        }\n    }\n    if (format === undefined) {\n        throw new Error('Unable to determine format for workspace path.');\n    }\n    let workspace;\n    switch (format) {\n        case WorkspaceFormat.JSON:\n            workspace = await (0, reader_1.readJsonWorkspace)(path, host);\n            break;\n        default:\n            throw new Error('Unsupported workspace format.');\n    }\n    formatLookup.set(workspace, WorkspaceFormat.JSON);\n    return { workspace };\n}\nexports.readWorkspace = readWorkspace;\n/**\n * Writes a `WorkspaceDefinition` to the underlying storage via the provided `WorkspaceHost`.\n * If the `WorkspaceDefinition` was created via the `readWorkspace` function, metadata will be\n * used to determine the path and format of the Workspace.  In all other cases, the `path` and\n * `format` options must be specified as they would be otherwise unknown.\n *\n * @param workspace The `WorkspaceDefinition` that will be written.\n * @param host The `WorkspaceHost` to use to access/write the file and directory data.\n * @param path The path to a file location for the output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n * @param format The `WorkspaceFormat` to use for output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n *\n *\n * @return An `Promise` of type `void`.\n */\nasync function writeWorkspace(workspace, host, path, format) {\n    if (format === undefined) {\n        format = formatLookup.get(workspace);\n        if (format === undefined) {\n            throw new Error('A format is required for custom workspace objects.');\n        }\n    }\n    switch (format) {\n        case WorkspaceFormat.JSON:\n            return (0, writer_1.writeJsonWorkspace)(workspace, host, path);\n        default:\n            throw new Error('Unsupported workspace format.');\n    }\n}\nexports.writeWorkspace = writeWorkspace;\n"]},"metadata":{},"sourceType":"script"}