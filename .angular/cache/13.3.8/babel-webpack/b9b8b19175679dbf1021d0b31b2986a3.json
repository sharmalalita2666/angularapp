{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readJsonWorkspace = void 0;\n\nconst parser_1 = require(\"../../json/parser\");\n\nconst definitions_1 = require(\"../definitions\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst utilities_1 = require(\"./utilities\");\n\nfunction readJsonWorkspace(_x, _x2) {\n  return _readJsonWorkspace.apply(this, arguments);\n}\n\nfunction _readJsonWorkspace() {\n  _readJsonWorkspace = _asyncToGenerator(function* (path, host) {\n    const raw = yield host.readFile(path);\n\n    if (raw === undefined) {\n      throw new Error('Unable to read workspace file.');\n    }\n\n    const ast = (0, parser_1.parseJsonAst)(raw, parser_1.JsonParseMode.Loose);\n\n    if (ast.kind !== 'object') {\n      throw new Error('Invalid workspace file - expected JSON object.');\n    } // Version check\n\n\n    const versionNode = ast.properties.find(pair => pair.key.value === 'version');\n\n    if (!versionNode) {\n      throw new Error('Unknown format - version specifier not found.');\n    }\n\n    const formatVersion = versionNode.value.value;\n\n    if (formatVersion !== 1) {\n      throw new Error(`Invalid format version detected - Expected:[ 1 ] Found: [ ${formatVersion} ]`);\n    }\n\n    const context = {\n      host,\n      metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n      trackChanges: true,\n\n      error(message, _node) {\n        // TODO: Diagnostic reporting support\n        throw new Error(message);\n      },\n\n      warn(_message, _node) {// TODO: Diagnostic reporting support\n      }\n\n    };\n    const workspace = parseWorkspace(ast, context);\n    return workspace;\n  });\n  return _readJsonWorkspace.apply(this, arguments);\n}\n\nexports.readJsonWorkspace = readJsonWorkspace;\nconst specialWorkspaceExtensions = ['cli', 'defaultProject', 'newProjectRoot', 'schematics'];\nconst specialProjectExtensions = ['cli', 'schematics', 'projectType'];\n\nfunction parseWorkspace(workspaceNode, context) {\n  const jsonMetadata = context.metadata;\n  let projects;\n  let projectsNode;\n  let extensions;\n\n  if (!context.trackChanges) {\n    extensions = Object.create(null);\n  }\n\n  for (const {\n    key,\n    value\n  } of workspaceNode.properties) {\n    const name = key.value;\n\n    if (name === '$schema' || name === 'version') {// skip\n    } else if (name === 'projects') {\n      if (value.kind !== 'object') {\n        context.error('Invalid \"projects\" field found; expected an object.', value);\n        continue;\n      }\n\n      projectsNode = value;\n      projects = parseProjectsObject(value, context);\n    } else {\n      if (!specialWorkspaceExtensions.includes(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n        context.warn(`Project extension with invalid name found.`, key);\n      }\n\n      if (extensions) {\n        extensions[name] = value.value;\n      }\n    }\n  }\n\n  let collectionListener;\n\n  if (context.trackChanges && projectsNode) {\n    const parentNode = projectsNode;\n\n    collectionListener = (name, action, newValue) => {\n      jsonMetadata.addChange(action, `/projects/${(0, utilities_1.escapeKey)(name)}`, parentNode, newValue, 'project');\n    };\n  }\n\n  const projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n  return {\n    [metadata_1.JsonWorkspaceSymbol]: jsonMetadata,\n    projects: projectCollection,\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions || (0, utilities_1.createVirtualAstObject)(workspaceNode, {\n      exclude: ['$schema', 'version', 'projects'],\n\n      listener(op, path, node, value) {\n        jsonMetadata.addChange(op, path, node, value);\n      }\n\n    })\n  };\n}\n\nfunction parseProjectsObject(projectsNode, context) {\n  const projects = Object.create(null);\n\n  for (const {\n    key,\n    value\n  } of projectsNode.properties) {\n    if (value.kind !== 'object') {\n      context.warn('Skipping invalid project value; expected an object.', value);\n      continue;\n    }\n\n    const name = key.value;\n    projects[name] = parseProject(name, value, context);\n  }\n\n  return projects;\n}\n\nfunction parseProject(projectName, projectNode, context) {\n  const jsonMetadata = context.metadata;\n  let targets;\n  let targetsNode;\n  let extensions;\n  let properties;\n\n  if (!context.trackChanges) {\n    // If not tracking changes, the parser will store the values directly in standard objects\n    extensions = Object.create(null);\n    properties = Object.create(null);\n  }\n\n  for (const {\n    key,\n    value\n  } of projectNode.properties) {\n    const name = key.value;\n\n    switch (name) {\n      case 'targets':\n      case 'architect':\n        if (value.kind !== 'object') {\n          context.error(`Invalid \"${name}\" field found; expected an object.`, value);\n          break;\n        }\n\n        targetsNode = value;\n        targets = parseTargetsObject(projectName, value, context);\n        break;\n\n      case 'prefix':\n      case 'root':\n      case 'sourceRoot':\n        if (value.kind !== 'string') {\n          context.warn(`Project property \"${name}\" should be a string.`, value);\n        }\n\n        if (properties) {\n          properties[name] = value.value;\n        }\n\n        break;\n\n      default:\n        if (!specialProjectExtensions.includes(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n          context.warn(`Project extension with invalid name found.`, key);\n        }\n\n        if (extensions) {\n          extensions[name] = value.value;\n        }\n\n        break;\n    }\n  }\n\n  let collectionListener;\n\n  if (context.trackChanges) {\n    if (targetsNode) {\n      const parentNode = targetsNode;\n\n      collectionListener = (name, action, newValue) => {\n        jsonMetadata.addChange(action, `/projects/${projectName}/targets/${(0, utilities_1.escapeKey)(name)}`, parentNode, newValue, 'target');\n      };\n    } else {\n      let added = false;\n\n      collectionListener = (_name, action, _new, _old, collection) => {\n        if (added || action !== 'add') {\n          return;\n        }\n\n        jsonMetadata.addChange('add', `/projects/${projectName}/targets`, projectNode, collection, 'targetcollection');\n        added = true;\n      };\n    }\n  }\n\n  const base = {\n    targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions || (0, utilities_1.createVirtualAstObject)(projectNode, {\n      exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n\n      listener(op, path, node, value) {\n        jsonMetadata.addChange(op, `/projects/${projectName}${path}`, node, value);\n      }\n\n    })\n  };\n  let project;\n\n  if (context.trackChanges) {\n    project = (0, utilities_1.createVirtualAstObject)(projectNode, {\n      base,\n      include: ['prefix', 'root', 'sourceRoot'],\n\n      listener(op, path, node, value) {\n        jsonMetadata.addChange(op, `/projects/${projectName}${path}`, node, value);\n      }\n\n    });\n  } else {\n    project = { ...base,\n      ...properties\n    };\n  }\n\n  return project;\n}\n\nfunction parseTargetsObject(projectName, targetsNode, context) {\n  const jsonMetadata = context.metadata;\n  const targets = Object.create(null);\n\n  for (const {\n    key,\n    value\n  } of targetsNode.properties) {\n    if (value.kind !== 'object') {\n      context.warn('Skipping invalid target value; expected an object.', value);\n      continue;\n    }\n\n    const name = key.value;\n\n    if (context.trackChanges) {\n      targets[name] = (0, utilities_1.createVirtualAstObject)(value, {\n        include: ['builder', 'options', 'configurations', 'defaultConfiguration'],\n\n        listener(op, path, node, value) {\n          jsonMetadata.addChange(op, `/projects/${projectName}/targets/${name}${path}`, node, value);\n        }\n\n      });\n    } else {\n      targets[name] = value.value;\n    }\n  }\n\n  return targets;\n}","map":{"version":3,"sources":["/home/unthinkable-lap-0268/Documents/angularProject/node_modules/@angular-devkit/core/src/workspace/json/reader.js"],"names":["Object","defineProperty","exports","value","readJsonWorkspace","parser_1","require","definitions_1","metadata_1","utilities_1","path","host","raw","readFile","undefined","Error","ast","parseJsonAst","JsonParseMode","Loose","kind","versionNode","properties","find","pair","key","formatVersion","context","metadata","JsonWorkspaceMetadata","trackChanges","error","message","_node","warn","_message","workspace","parseWorkspace","specialWorkspaceExtensions","specialProjectExtensions","workspaceNode","jsonMetadata","projects","projectsNode","extensions","create","name","parseProjectsObject","includes","test","collectionListener","parentNode","action","newValue","addChange","escapeKey","projectCollection","ProjectDefinitionCollection","JsonWorkspaceSymbol","createVirtualAstObject","exclude","listener","op","node","parseProject","projectName","projectNode","targets","targetsNode","parseTargetsObject","added","_name","_new","_old","collection","base","TargetDefinitionCollection","project","include"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readJsonWorkspace = void 0;\nconst parser_1 = require(\"../../json/parser\");\nconst definitions_1 = require(\"../definitions\");\nconst metadata_1 = require(\"./metadata\");\nconst utilities_1 = require(\"./utilities\");\nasync function readJsonWorkspace(path, host) {\n    const raw = await host.readFile(path);\n    if (raw === undefined) {\n        throw new Error('Unable to read workspace file.');\n    }\n    const ast = (0, parser_1.parseJsonAst)(raw, parser_1.JsonParseMode.Loose);\n    if (ast.kind !== 'object') {\n        throw new Error('Invalid workspace file - expected JSON object.');\n    }\n    // Version check\n    const versionNode = ast.properties.find((pair) => pair.key.value === 'version');\n    if (!versionNode) {\n        throw new Error('Unknown format - version specifier not found.');\n    }\n    const formatVersion = versionNode.value.value;\n    if (formatVersion !== 1) {\n        throw new Error(`Invalid format version detected - Expected:[ 1 ] Found: [ ${formatVersion} ]`);\n    }\n    const context = {\n        host,\n        metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n        trackChanges: true,\n        error(message, _node) {\n            // TODO: Diagnostic reporting support\n            throw new Error(message);\n        },\n        warn(_message, _node) {\n            // TODO: Diagnostic reporting support\n        },\n    };\n    const workspace = parseWorkspace(ast, context);\n    return workspace;\n}\nexports.readJsonWorkspace = readJsonWorkspace;\nconst specialWorkspaceExtensions = ['cli', 'defaultProject', 'newProjectRoot', 'schematics'];\nconst specialProjectExtensions = ['cli', 'schematics', 'projectType'];\nfunction parseWorkspace(workspaceNode, context) {\n    const jsonMetadata = context.metadata;\n    let projects;\n    let projectsNode;\n    let extensions;\n    if (!context.trackChanges) {\n        extensions = Object.create(null);\n    }\n    for (const { key, value } of workspaceNode.properties) {\n        const name = key.value;\n        if (name === '$schema' || name === 'version') {\n            // skip\n        }\n        else if (name === 'projects') {\n            if (value.kind !== 'object') {\n                context.error('Invalid \"projects\" field found; expected an object.', value);\n                continue;\n            }\n            projectsNode = value;\n            projects = parseProjectsObject(value, context);\n        }\n        else {\n            if (!specialWorkspaceExtensions.includes(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n                context.warn(`Project extension with invalid name found.`, key);\n            }\n            if (extensions) {\n                extensions[name] = value.value;\n            }\n        }\n    }\n    let collectionListener;\n    if (context.trackChanges && projectsNode) {\n        const parentNode = projectsNode;\n        collectionListener = (name, action, newValue) => {\n            jsonMetadata.addChange(action, `/projects/${(0, utilities_1.escapeKey)(name)}`, parentNode, newValue, 'project');\n        };\n    }\n    const projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n    return {\n        [metadata_1.JsonWorkspaceSymbol]: jsonMetadata,\n        projects: projectCollection,\n        // If not tracking changes the `extensions` variable will contain the parsed\n        // values.  Otherwise the extensions are tracked via a virtual AST object.\n        extensions: extensions ||\n            (0, utilities_1.createVirtualAstObject)(workspaceNode, {\n                exclude: ['$schema', 'version', 'projects'],\n                listener(op, path, node, value) {\n                    jsonMetadata.addChange(op, path, node, value);\n                },\n            }),\n    };\n}\nfunction parseProjectsObject(projectsNode, context) {\n    const projects = Object.create(null);\n    for (const { key, value } of projectsNode.properties) {\n        if (value.kind !== 'object') {\n            context.warn('Skipping invalid project value; expected an object.', value);\n            continue;\n        }\n        const name = key.value;\n        projects[name] = parseProject(name, value, context);\n    }\n    return projects;\n}\nfunction parseProject(projectName, projectNode, context) {\n    const jsonMetadata = context.metadata;\n    let targets;\n    let targetsNode;\n    let extensions;\n    let properties;\n    if (!context.trackChanges) {\n        // If not tracking changes, the parser will store the values directly in standard objects\n        extensions = Object.create(null);\n        properties = Object.create(null);\n    }\n    for (const { key, value } of projectNode.properties) {\n        const name = key.value;\n        switch (name) {\n            case 'targets':\n            case 'architect':\n                if (value.kind !== 'object') {\n                    context.error(`Invalid \"${name}\" field found; expected an object.`, value);\n                    break;\n                }\n                targetsNode = value;\n                targets = parseTargetsObject(projectName, value, context);\n                break;\n            case 'prefix':\n            case 'root':\n            case 'sourceRoot':\n                if (value.kind !== 'string') {\n                    context.warn(`Project property \"${name}\" should be a string.`, value);\n                }\n                if (properties) {\n                    properties[name] = value.value;\n                }\n                break;\n            default:\n                if (!specialProjectExtensions.includes(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n                    context.warn(`Project extension with invalid name found.`, key);\n                }\n                if (extensions) {\n                    extensions[name] = value.value;\n                }\n                break;\n        }\n    }\n    let collectionListener;\n    if (context.trackChanges) {\n        if (targetsNode) {\n            const parentNode = targetsNode;\n            collectionListener = (name, action, newValue) => {\n                jsonMetadata.addChange(action, `/projects/${projectName}/targets/${(0, utilities_1.escapeKey)(name)}`, parentNode, newValue, 'target');\n            };\n        }\n        else {\n            let added = false;\n            collectionListener = (_name, action, _new, _old, collection) => {\n                if (added || action !== 'add') {\n                    return;\n                }\n                jsonMetadata.addChange('add', `/projects/${projectName}/targets`, projectNode, collection, 'targetcollection');\n                added = true;\n            };\n        }\n    }\n    const base = {\n        targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n        // If not tracking changes the `extensions` variable will contain the parsed\n        // values.  Otherwise the extensions are tracked via a virtual AST object.\n        extensions: extensions ||\n            (0, utilities_1.createVirtualAstObject)(projectNode, {\n                exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n                listener(op, path, node, value) {\n                    jsonMetadata.addChange(op, `/projects/${projectName}${path}`, node, value);\n                },\n            }),\n    };\n    let project;\n    if (context.trackChanges) {\n        project = (0, utilities_1.createVirtualAstObject)(projectNode, {\n            base,\n            include: ['prefix', 'root', 'sourceRoot'],\n            listener(op, path, node, value) {\n                jsonMetadata.addChange(op, `/projects/${projectName}${path}`, node, value);\n            },\n        });\n    }\n    else {\n        project = {\n            ...base,\n            ...properties,\n        };\n    }\n    return project;\n}\nfunction parseTargetsObject(projectName, targetsNode, context) {\n    const jsonMetadata = context.metadata;\n    const targets = Object.create(null);\n    for (const { key, value } of targetsNode.properties) {\n        if (value.kind !== 'object') {\n            context.warn('Skipping invalid target value; expected an object.', value);\n            continue;\n        }\n        const name = key.value;\n        if (context.trackChanges) {\n            targets[name] = (0, utilities_1.createVirtualAstObject)(value, {\n                include: ['builder', 'options', 'configurations', 'defaultConfiguration'],\n                listener(op, path, node, value) {\n                    jsonMetadata.addChange(op, `/projects/${projectName}/targets/${name}${path}`, node, value);\n                },\n            });\n        }\n        else {\n            targets[name] = value.value;\n        }\n    }\n    return targets;\n}\n"]},"metadata":{},"sourceType":"script"}